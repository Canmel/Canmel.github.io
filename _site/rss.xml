<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Meedesidy Blog</title>
        <description>Meedesidy Blog - Meedesidy</description>
        <link>http://canmel.github.io</link>
        <link>http://canmel.github.io</link>
        <lastBuildDate>2017-12-31T22:05:56+08:00</lastBuildDate>
        <pubDate>2017-12-31T22:05:56+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>spring-boot 坑坑洼洼的小路</title>
                <description>&lt;p&gt;服务器打jar包部署问题解决&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;问题描述&quot;&gt;问题描述：&lt;/h2&gt;
&lt;h3 id=&quot;最近在看spring-boot的东西pomxml基本的内容包括&quot;&gt;最近在看spring-boot的东西，POM.xml基本的内容包括：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	&amp;lt;parent&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;1.5.6.RELEASE&amp;lt;/version&amp;gt;
		&amp;lt;relativePath /&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
	&amp;lt;/parent&amp;gt;
	
		&amp;lt;properties&amp;gt;
		&amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
		&amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
		&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
	&amp;lt;/properties&amp;gt;
	
	&amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;

		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
		&amp;lt;/dependency&amp;gt;

		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
    &amp;lt;dependencies&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;出现的问题&quot;&gt;出现的问题：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;本地eclipse上 &lt;code&gt;Run As Application&lt;/code&gt;正常访问，正常使用&lt;/li&gt;
  &lt;li&gt;本地使用 &lt;code&gt;mvn spring-boot:run &lt;/code&gt;，正常启动，正常使用&lt;/li&gt;
  &lt;li&gt;服务器使用&lt;code&gt;jar&lt;/code&gt;包启动，&lt;code&gt;java -jar xxxxxx.jar&lt;/code&gt;, 访问的各页面找不到，404&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;x.x.x.x ERROR template might not exist or might not be accessible by any of the configured Template Resolvers
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;可用的解决方法&quot;&gt;可用的解决方法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;可能是静态资源没有打进&lt;code&gt;jar&lt;/code&gt;包，在&lt;code&gt;mapper&lt;/code&gt;中加入&lt;code&gt;&amp;lt;build&amp;gt;&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;build&amp;gt;
 &amp;lt;resources&amp;gt;
 		&amp;lt;resource&amp;gt;
 			&amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
 			&amp;lt;includes&amp;gt;
 				&amp;lt;include&amp;gt;**/*.*&amp;lt;/include&amp;gt;
 			&amp;lt;/includes&amp;gt;
 			&amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
 		&amp;lt;/resource&amp;gt;
 		&amp;lt;resource&amp;gt;
 			&amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
 			&amp;lt;includes&amp;gt;
 				&amp;lt;include&amp;gt;**/*.*&amp;lt;/include&amp;gt;
 			&amp;lt;/includes&amp;gt;
 			&amp;lt;excludes&amp;gt;
 				&amp;lt;exclude&amp;gt;**/*.java&amp;lt;/exclude&amp;gt;
 			&amp;lt;/excludes&amp;gt;
 			&amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
 		&amp;lt;/resource&amp;gt;
 	&amp;lt;/resources&amp;gt;
 &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;theamleaf&lt;/code&gt;支持强格式的H5语法，可以严格将&lt;code&gt;html&lt;/code&gt;标签全部对应结束标签，或者让其支持不严格的&lt;code&gt;html&lt;/code&gt;标签&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;dependency&amp;gt;
 	&amp;lt;groupId&amp;gt;net.sourceforge.nekohtml&amp;lt;/groupId&amp;gt;
 	&amp;lt;artifactId&amp;gt;nekohtml&amp;lt;/artifactId&amp;gt;
 &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后在品配置文件中加入:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; spring:
   aop:
     auto: true
   thymeleaf:
     suffix: .html
     prefix: classpath:/templates/
     encoding: UTF-8
     mode: LEGACYHTML5   ## 支持不严格的Html格式
     content-type: text/html
     cache: false
    
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可能是启用了&lt;code&gt;theamleaf&lt;/code&gt;的默认配置,&lt;code&gt;theamleaf&lt;/code&gt;默认前缀&lt;code&gt;/templates/&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（我的错误就是这个造成的）在&lt;code&gt;controller&lt;/code&gt;中&lt;code&gt;return&lt;/code&gt;了的&lt;code&gt;viewName&lt;/code&gt;前面有&lt;code&gt;/&lt;/code&gt;,造成在&lt;code&gt;jar&lt;/code&gt;包里面没有走相对的路径，删除返回页面的前置的斜杠&lt;code&gt;/&lt;/code&gt;即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://canmel.github.io/2017/12/31/spring-boot-%E5%9D%91%E5%9D%91%E6%B4%BC%E6%B4%BC%E7%9A%84%E5%B0%8F%E8%B7%AF</link>
                <guid>http://canmel.github.io/2017/12/31/spring-boot 坑坑洼洼的小路</guid>
                <pubDate>2017-12-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>GitLab ci 持续自动化坑坑洼洼的小路</title>
                <description>&lt;h2 id=&quot;centos上使用gitlab-ci持续集成&quot;&gt;CentOs上使用gitLab-ci持续集成&lt;/h2&gt;

&lt;h3 id=&quot;安装gitlab-runner&quot;&gt;安装GitLab-Runner&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash
$ yum install gitlab-ci-multi-runner

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;将单独的gitlab-runner注册到gitlab上&quot;&gt;将单独的GitLab-Runner注册到GitLab上&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
$ gitlab-ci-multi-runner register
#引导会让你输入gitlab的url，输入自己的url，例如http://gitlab.example.com/
#引导会让你输入token，去相应的项目下找到token，例如ase12c235qazd32
#引导会让你输入tag，一个项目可能有多个runner，是根据tag来区别runner的，输入若干个就好了，比如web,hook,deploy
#引导会让你输入executor，这个是要用什么方式来执行脚本，图方便输入shell就好了。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;url 和 token 在每个项目的setting/(CI/DI)/Runners settings 中&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;编写gitlab-ciyml&quot;&gt;编写.gitlab-ci.yml,&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;位置: 项目根目录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;push: gitlab-ci就会自动识别来解析&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;
## 最简单的ci文件
build:
    script: &quot;pwd&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;## 步骤列表
stages:   
    ## 每一个stages都会在GitLab的Pipeline中以job的形式先后顺序执行    
  - build 
  - deploy
build:
    stage: build
    ## 需要执行的动作
    script: 
      - pwd &amp;amp;&amp;amp; echo &quot;可以执行测试命令&quot; &amp;amp;&amp;amp; echo $DEPLOY_PATH
deploy:
    stage: deploy
    script: 
      - echo &quot;我是好人&quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;坑坑洼洼的路&quot;&gt;坑坑洼洼的路&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;runner使用Docker，ci开始时候回clone代码至Docker容器，走的是&lt;code&gt;/etc/gitlab/gitlab.rb&lt;/code&gt;中定义的&lt;code&gt;external_url&lt;/code&gt;，so, 我之前给的&lt;code&gt;127.0.0.1&lt;/code&gt;或者&lt;code&gt;localhost&lt;/code&gt;就开始万马奔腾了&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://canmel.github.io/2017/12/12/gitlab-ci-%E6%8C%81%E7%BB%AD%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9D%91%E5%9D%91%E6%B4%BC%E6%B4%BC%E7%9A%84%E5%B0%8F%E8%B7%AF</link>
                <guid>http://canmel.github.io/2017/12/12/gitlab-ci-持续自动化坑坑洼洼的小路</guid>
                <pubDate>2017-12-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mysql Operation not permitted</title>
                <description>&lt;h2 id=&quot;场景&quot;&gt;场景&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;安装完&lt;code&gt;mysql&lt;/code&gt;,发现命令行中没有&lt;code&gt;mysql&lt;/code&gt;的命令，再找到&lt;code&gt;mysql&lt;/code&gt;命令在&lt;code&gt;/usr/local/mysql/bin/&lt;/code&gt;下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;计划&quot;&gt;计划&lt;/h2&gt;
&lt;p&gt;本来想把&lt;code&gt;mysql/bin&lt;/code&gt;下的&lt;code&gt;mysql&lt;/code&gt;命令在&lt;code&gt;/usr/bin&lt;/code&gt;下创建一个软链接。但是需要权限。&lt;/p&gt;

&lt;p&gt;当我再次sudo执行，还是抛出&lt;code&gt;mysql Operation not permitted&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;

&lt;p&gt;这是因为苹果在OS X 10.11中引入的SIP特性使得即使加了&lt;code&gt;sudo&lt;/code&gt;（也就是具有root权限）也无法修改系统级的目录，其中就包括了/usr/bin。要解决这个问题有两种做法：&lt;/p&gt;

&lt;p&gt;一种是比较不安全的就是关闭&lt;code&gt;SIP&lt;/code&gt;，也就是&lt;code&gt;rootless&lt;/code&gt;特性；&lt;/p&gt;

&lt;p&gt;另一种是将本要链接到&lt;code&gt;/usr/bin&lt;/code&gt;下的改链接到&lt;code&gt;/usr/local/bin&lt;/code&gt;下就好了。&lt;/p&gt;

&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo ln -s /usr/local/mysql/bin/mysql /usr/local/bin&lt;/p&gt;
&lt;/blockquote&gt;

</description>
                <link>http://canmel.github.io/2017/12/05/mysql-operation-not-permitted</link>
                <guid>http://canmel.github.io/2017/12/05/mysql-operation-not-permitted</guid>
                <pubDate>2017-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>centos安装部署gitlab服务器</title>
                <description>&lt;h2 id=&quot;1-安装依赖软件&quot;&gt;1. 安装依赖软件&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;yum -y install policycoreutils openssh-server openssh-clients postfix&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2设置postfix开机自启并启动postfix支持gitlab发信功能&quot;&gt;2.设置postfix开机自启，并启动，postfix支持gitlab发信功能&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;systemctl enable postfix &amp;amp;&amp;amp; systemctl start postfix&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3下载gitlab安装包然后安装&quot;&gt;3.下载gitlab安装包，然后安装&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;查看系统版本&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;cat /etc/os-release&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;centos 6系统的下载地址:&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;centos 7系统的下载地址:&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;安装&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;rpm -i gitlab-ce-x.x.x-ce.x.x.x.x86_64.rpm&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4修改gitlab配置文件指定服务器ip和自定义端口&quot;&gt;4.修改gitlab配置文件指定服务器ip和自定义端口&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;vim  /etc/gitlab/gitlab.rb&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;## 设置访问路径，http://127.0.0.1 
## 注意这里设置的端口不能被占用，默认是8080又好像就是80端口，如果8080已经使用，请自定义其它端口，并在防火墙设置开放相对应得端口
external_url 'http://127.0.0.1'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;5重置并启动gitlab&quot;&gt;5.重置并启动GitLab&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;重新使用新配置
    &lt;blockquote&gt;
      &lt;p&gt;gitlab-ctl reconfigure&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;重启
    &lt;blockquote&gt;
      &lt;p&gt;gitlab-ctl restart&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6访问-gitlab页面&quot;&gt;6.访问 GitLab页面&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果没有域名，直接输入服务器ip和指定端口进行访问&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;初始账户: root 密码: 5iveL!fe&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;第一次登录修改密码,第一次访问直接让你修改密码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7局域网hostname访问&quot;&gt;7.局域网hostname访问&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;vi /etc/hosts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;apple js
192.168.xxx.xxx code.xxx.xxx
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;访问 code.xxx.xxx&lt;/strong&gt;&lt;/p&gt;

</description>
                <link>http://canmel.github.io/2017/12/05/centos%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2gitLab</link>
                <guid>http://canmel.github.io/2017/12/05/centos安装部署gitLab</guid>
                <pubDate>2017-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>HttpClient各版本发送请求</title>
                <description>&lt;h2 id=&quot;httpclient大致分为三个版本&quot;&gt;HttpClient大致分为三个版本：&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HttpClient 3.x&lt;/li&gt;
  &lt;li&gt;HttpClient 4.x – HttpClient 4.3&lt;/li&gt;
  &lt;li&gt;HttpClient 4.3 及以上&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;httpclient-3x&quot;&gt;HttpClient 3.x&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;HttpClient client = new HttpClient();  
HttpMethodmethod = new GetMethod(&quot;http://java.sun.com&quot;);  
// 使用POST方法  
// HttpMethod method = new PostMethod(&quot;http://java.sun.com&quot;);  
client.executeMethod(method);  
// 打印服务器返回的状态  
System.out.println(method.getStatusLine());  
// 打印返回的信息  
System.out.println(method.getResponseBodyAsString());  
// 释放连接  
method.releaseConnection();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpclient-4x--httpclient-43&quot;&gt;HttpClient 4.x – HttpClient 4.3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void getUrl(String url, String encoding) throws ClientProtocolException, IOException {  
    HttpClient client = new DefaultHttpClient();  
    HttpGet get = new HttpGet(url);  
    //设置超时时间  
    HttpParams params = client.getParams();  
    HttpConnectionParams.setConnectionTimeout(params, (int) 10 * 1000);  
    HttpConnectionParams.setSoTimeout(params, 10 * 1000);  
    HttpResponse response = client.execute(get);  
    HttpEntity entity = response.getEntity();  
    if (entity != null) {  
        InputStream instream = entity.getContent();  
        try {  
            BufferedReader reader = new BufferedReader(new InputStreamReader(instream, encoding));  
                System.out.println(reader.readLine());  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                instream.close();  
            }  
        }  
        // 关闭连接.  
        client.getConnectionManager().shutdown();  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpclient-43-及以上&quot;&gt;HttpClient 4.3 及以上&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import org.apache.http.HttpEntity;  
import org.apache.http.HttpResponse;  
import org.apache.http.client.methods.HttpGet;  
import org.apache.http.impl.client.CloseableHttpClient;  
import org.apache.http.impl.client.HttpClients;  
import org.apache.http.util.EntityUtils;  
  
  
public static String getResult(String urlStr) {  
    CloseableHttpClient httpClient = HttpClients.createDefault();  
    // HTTP Get请求  
    HttpGet httpGet = new HttpGet(urlStr);  
    // 设置请求和传输超时时间  
    // RequestConfig requestConfig =  
    // RequestConfig.custom().setSocketTimeout(TIME_OUT).setConnectTimeout(TIME_OUT).build();  
    // httpGet.setConfig(requestConfig);  
    String res = &quot;&quot;;  
    try {  
        // 执行请求  
        HttpResponse getAddrResp = httpClient.execute(httpGet);  
        HttpEntity entity = getAddrResp.getEntity();  
        if (entity != null) {  
            res = EntityUtils.toString(entity);  
        }  
            log.info(&quot;响应&quot; + getAddrResp.getStatusLine());  
        } catch (Exception e) {  
            log.error(e.getMessage(), e);  
            return res;  
        } finally {  
            try {  
                httpClient.close();  
            } catch (IOException e) {  
                log.error(e.getMessage(), e);  
                return res;  
            }  
        }  
        return res;  
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;各版本注意事项&quot;&gt;各版本注意事项&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;无论是哪个版本，那种请求方式类（HttpPost, HttpGet, PostMethod, GetMethod）,在传递参数的时候一定要注意加上参数编码&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JAVA&quot;&gt;PostMethod postMethod = new PostMethod();
...
List&amp;lt;NameValuePair&amp;gt; nvps = new ArrayList&amp;lt;NameValuePair&amp;gt;();
...
httpPost.setEntity(new UrlEncodedFormEntity(nvps, charset));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;导包，添加maven依赖的时候要注意，其中3.X版本的是&lt;code&gt;org.apache.commons.httpclient.HttpClient&lt;/code&gt;, maven仓库上最高版本&lt;code&gt;3.1&lt;/code&gt;，(截止&lt;code&gt;Aug, 2007&lt;/code&gt;已经不再维护)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;org.apache.http.client.HttpClient&lt;/code&gt;继续在之前的版本维护，第一个版本为&lt;code&gt;4.0xx&lt;/code&gt;，4.0以后的版本支持SSL&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;40---43-示例&quot;&gt;4.0 - 4.3 示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class HttpClientT {
	
	private static String error_result = &quot;Request Error&quot;;

	public static String doPostStr(String url, String params, String charset) {
		String result = &quot;&quot;;
		HttpClient httpClient = new DefaultHttpClient();
		HttpUriRequest httpPost = null;
		try {
			httpPost = new HttpPost(url);
			((HttpPost)httpPost).setEntity(new StringEntity(params, charset));
			setHeaderParams(httpPost, charset);
			HttpResponse response = httpClient.execute(httpPost);
			if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
				HttpEntity resultEntity = response.getEntity();
				result = EntityUtils.toString(resultEntity);
			}
		} catch (IOException e) {
			e.printStackTrace();
			result = error_result;
		}
		return result;
	}
	
	public static String doPost(String url, Map&amp;lt;String, String&amp;gt; params, String charset) {
		HttpClient httpClient = new DefaultHttpClient();
		String result = &quot;&quot;;
		
		HttpPost httpPost = null;
		List&amp;lt;NameValuePair&amp;gt; nvps = new ArrayList&amp;lt;NameValuePair&amp;gt;();

		if (null != params) {
			for (Map.Entry&amp;lt;String, String&amp;gt; item : params.entrySet()) {
				nvps.add(new BasicNameValuePair((String) item.getKey(), (String) item.getValue()));
			}
		}
		try {
			httpPost = new HttpPost(url);
			httpPost.setEntity(new UrlEncodedFormEntity(nvps, charset));
			setHeaderParams(httpPost, charset);
			HttpResponse response = httpClient.execute(httpPost);
			if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
				HttpEntity resultEntity = response.getEntity();
				result = EntityUtils.toString(resultEntity);
			}
		} catch (IOException e) {
			e.printStackTrace();
			result = error_result;
		}
		return result;
	}
	
	public static void setHeaderParams(HttpUriRequest req, String charset) {
		req.setHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded; charset=&quot; + charset);
		req.setHeader(&quot;Accept-Language&quot;, &quot;zh-cn&quot;);
		req.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
		req.setHeader(&quot;Connection&quot;, &quot;Close&quot;);
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

</description>
                <link>http://canmel.github.io/2017/11/07/HttpClient%E5%90%84%E7%89%88%E6%9C%AC%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82</link>
                <guid>http://canmel.github.io/2017/11/07/HttpClient各版本发送请求</guid>
                <pubDate>2017-11-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>JAVA问答</title>
                <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&quot;java基础&quot;&gt;JAVA基础&lt;/h1&gt;
&lt;h2 id=&quot;--实例方法和静态方法有什么不一样&quot;&gt;- 实例方法和静态方法有什么不一样&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;从调用上来看，实例方法需要使用对象来调用, 静态方法则是由类直接调用的&lt;/li&gt;
    &lt;li&gt;在同一个类中，实例方法内部可以直接使用静态方法，但是静态方法中则无法直接调用这个实例方法&lt;/li&gt;
    &lt;li&gt;介于实例方法和静态方法的修饰符有差异，这也算是一种不一样吧。另外，实例方法属于对应类的实例的行为，而静态方法是属于类的行为&lt;/li&gt;
    &lt;li&gt;静态方法多用作工具类的方法。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;--java中的异常有哪几类分别怎么使用&quot;&gt;- Java中的异常有哪几类？分别怎么使用&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Throwable 类是Java语言中所有错误或异常的超类, Throwable包含了错误(Error)和异常(Excetion两类)&lt;/li&gt;
    &lt;li&gt;Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)&lt;/li&gt;
    &lt;li&gt;Error是程序无法处理了, 如果OutOfMemoryError、OutOfMemoryError等等, 这些异常发生时, java虚拟机一般会终止线程 .&lt;/li&gt;
    &lt;li&gt;运行时异常都是RuntimeException类及其子类,如 NullPointerException、IndexOutOfBoundsException等, 这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉. 这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免&lt;/li&gt;
    &lt;li&gt;检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译. 如IOException、SQLException等&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;--常用的集合类有哪些特点&quot;&gt;- 常用的集合类有哪些？特点？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Java集合如Map、Set、List等所有集合只能存放引用类型数据，它们都是存放引用类型数据的容器，不能存放如int、long、float、double等基础类型的数据。泛型设置基本类型不能通过编译，不设置泛型在加入元素的时候会自动装箱成包装类&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;结构&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Collection
    &lt;ul&gt;
      &lt;li&gt;Set            无序，不允许重复
        &lt;ul&gt;
          &lt;li&gt;HashSet：哈希表｜无序｜元素必须实现HashCode()｜&lt;/li&gt;
          &lt;li&gt;TreeSet：二差树｜自动排升序&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;List           有序，可以有重复元素。
        &lt;ul&gt;
          &lt;li&gt;ArrayList：动态数组｜　查询↑　&lt;/li&gt;
          &lt;li&gt;LinkedList：链表｜插入和删除↑&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Map　都可以用来存放java对象
    &lt;ul&gt;
      &lt;li&gt;HashMap　异步　不是线程安全的　效率↑　允许空键值｜数组结合链表&lt;/li&gt;
      &lt;li&gt;Hashtable 同步　线程安全　效率↓&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Set和List对比&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ArrayList和LinkedList&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt;,是数组结构：少用与中间的增删。多用于查询，修改。每次增删元素顺序都会操作每个元素。
&lt;code&gt;LinkedList&lt;/code&gt;,是链表结构：多用于中间，开头增删。少用查询，修改。查询时会遍历大量元素。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;--集合排序&quot;&gt;- 集合排序&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;java集合的工具类&lt;strong&gt;Collections&lt;/strong&gt;中提供了两种排序的方法,分别是:
    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;Collections.sort(List list)&lt;/code&gt;｜自然排序&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Collections.sort(List list,Comparator c)&lt;/code&gt;｜定制排序｜需要new一个&lt;code&gt;Comparator&lt;/code&gt;接口的比较器对象&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt;排序
    &lt;ol&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;code&gt;Collections.sort(List list,Comparator)&lt;/code&gt;&lt;/td&gt;
              &lt;td&gt;&lt;code&gt;list&lt;/code&gt;为&lt;code&gt;Map&lt;/code&gt;的键或值的集合&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;使用&lt;code&gt;TreeMap(Comparator comparator)&lt;/code&gt;,创建自定义比较器的&lt;code&gt;TreeMap,putAll(map)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;遍历排序&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--内存溢出是怎么回事&quot;&gt;- 内存溢出是怎么回事?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;对象有被指向的引用，但是再也用不到它就是内存溢出了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--和equals的区别&quot;&gt;- ==和equals的区别？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;==&lt;/code&gt;判断对象物理地址.&lt;code&gt;equals&lt;/code&gt;判断对象&lt;code&gt;Value&lt;/code&gt;是否相等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// java.lang.Object

public boolean equals(Object obj) {
    return (this == obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--hashcode方法的作用&quot;&gt;- hashCode方法的作用？&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在hashMap中使用，把一个对象变成一个整型。hashCode规范，如果两个对象的equals返回true，那他们的hashCode必须相等，但是hashCode相等，不一定equals不一定相等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--object类中有哪些方法列举3个以上&quot;&gt;- Object类中有哪些方法？列举3个以上。&lt;/h2&gt;
&lt;p&gt;构造方法，&lt;code&gt;toString()&lt;/code&gt;，&lt;code&gt;equals&lt;/code&gt;，&lt;code&gt;hashCode&lt;/code&gt;，&lt;code&gt;getClass&lt;/code&gt;,&lt;code&gt;finalize&lt;/code&gt;,&lt;code&gt;clone&lt;/code&gt;,三个&lt;code&gt;wait()&lt;/code&gt;,&lt;code&gt;notify&lt;/code&gt;,&lt;code&gt;notifyAll&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--nio是什么适用于何种场景&quot;&gt;- NIO是什么？适用于何种场景？&lt;/h2&gt;
&lt;p&gt;NIO是newIO,接口都是异步的，非阻塞的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--如何实现线程安全的hashmap&quot;&gt;- 如何实现线程安全的HashMap？&lt;/h2&gt;

&lt;p&gt;线程安全：ConcurrentHashMap(系统自带的线程安全的HashMap),Map&amp;lt;Object, Object&amp;gt; synchronizedMap = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;()); synchronizedMap 为线程安全的Map.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--java一个字符占多少个字节int-long-double占多少字节&quot;&gt;- Java一个字符占多少个字节，int, long, double占多少字节&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个字符两个字节，int 4 , long double 8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--创建一个类的实例都有哪些办法&quot;&gt;- 创建一个类的实例都有哪些办法？&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code&gt;new Constructor()&lt;/code&gt; 最常见的&lt;/li&gt;
    &lt;li&gt;Class类的&lt;code&gt;newInstance&lt;/code&gt;方法:&lt;code&gt;Student stu = Student.class.newInstance();&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;java.lang.reflect.Constructor 的newInstance&lt;/li&gt;
    &lt;li&gt;调用一个对象的clone方法，JVM就会创建一个新的对象&lt;/li&gt;
    &lt;li&gt;使用反序列化,需要让我们的类实现Serializable接口&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--finalfinallyfinalize的区别&quot;&gt;- final/finally/finalize的区别？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;final是类，变量，方法的修饰。类被修饰后不能再被继承。变量和方法被修饰不能再被修改&lt;/li&gt;
  &lt;li&gt;finally是try…catch后执行的finally，&lt;/li&gt;
  &lt;li&gt;finalize,在Object中的方法名，在此对象被回收前会执行这个方法。（当使用文件流时，如果对象被回收，没有关闭流，在底层就会实现内存泄露）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;--sessioncookie的区别&quot;&gt;- Session/Cookie的区别？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;cookie数据存放在客户的浏览器上，session数据放在服务器上。&lt;/li&gt;
  &lt;li&gt;cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗&lt;/li&gt;
  &lt;li&gt;session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
 考虑到减轻服务器性能方面，应当使用COOKIE。&lt;/li&gt;
  &lt;li&gt;单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie&lt;/li&gt;
  &lt;li&gt;将登陆信息等重要信息存放为SESSION,其他信息如果需要保留，可以放在COOKIE中&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--servlet的生命周期&quot;&gt;- Servlet的生命周期？&lt;/h2&gt;
&lt;p&gt;初始化，服务处理（接收请求，处理请求，返回结果），销毁&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;框架使用&quot;&gt;框架使用&lt;/h1&gt;
&lt;h2 id=&quot;--你是怎么理解ioc的&quot;&gt;- 你是怎么理解IOC的&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--你是怎么理解aop的&quot;&gt;- 你是怎么理解AOP的&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;用途:　日志记录，性能统计，安全控制，权限管理，事务处理，异常处理，资源池管理。&lt;/li&gt;
    &lt;li&gt;面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，&lt;/li&gt;
    &lt;li&gt;通过spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面代码使用AOP设置事物&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&amp;gt;
    &amp;lt;!-- 使用注解的包，包括子集 --&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.eam&quot; /&amp;gt;
    &amp;lt;mvc:annotation-driven /&amp;gt;
 
    &amp;lt;!-- JNDI方式配置数据源 --&amp;gt;
    &amp;lt;!-- &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&amp;gt; 
        &amp;lt;property name=&quot;jndiName&quot; value=&quot;${jndiName}&quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; --&amp;gt;
 
    &amp;lt;!-- 这里Id与SessionContext要同步 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&amp;gt;
        &amp;lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
 
    &amp;lt;!-- 配置事务管理器 --&amp;gt;
    &amp;lt;bean name=&quot;transactionManager&quot;
        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
 
    &amp;lt;!-- 拦截器方式配置事物 --&amp;gt;
    &amp;lt;tx:advice id=&quot;transactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&amp;gt;
        &amp;lt;tx:attributes&amp;gt;
            &amp;lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;repair&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&amp;gt;
 
            &amp;lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;select*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&amp;gt;
            &amp;lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&amp;gt;
        &amp;lt;/tx:attributes&amp;gt;
    &amp;lt;/tx:advice&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut id=&quot;transactionPointcut&quot;
            expression=&quot;execution(* com.eam.service..*Impl.*(..))&quot; /&amp;gt;
        &amp;lt;aop:advisor pointcut-ref=&quot;transactionPointcut&quot;
            advice-ref=&quot;transactionAdvice&quot; /&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--spring中bean的生命周期&quot;&gt;- Spring中Bean的生命周期&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;实例化一个Bean－－也就是我们常说的new；&lt;/li&gt;
    &lt;li&gt;按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；&lt;/li&gt;
    &lt;li&gt;如果这个Bean已经实现了&lt;code&gt;BeanNameAware&lt;/code&gt;接口，会调用它实现的&lt;code&gt;setBeanName(String)&lt;/code&gt;方法&lt;/li&gt;
    &lt;li&gt;如果这个Bean已经实现了&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口，会调用它实现的&lt;code&gt;setBeanFactory(setBeanFactory(BeanFactory)&lt;/code&gt;传递的是Spring工厂自身&lt;/li&gt;
    &lt;li&gt;如果这个Bean已经实现了&lt;code&gt;ApplicationContextAware&lt;/code&gt;接口，会调用&lt;code&gt;setApplicationContext(ApplicationContext)&lt;/code&gt;方法，传入Spring上下文&lt;/li&gt;
    &lt;li&gt;如果这个Bean关联了&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口，将会调用&lt;code&gt;postProcessBeforeInitialization(Object obj, String s)&lt;/code&gt;方法，&lt;code&gt;BeanPostProcessor&lt;/code&gt;经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术&lt;/li&gt;
    &lt;li&gt;如果Bean在Spring配置文件中配置了&lt;code&gt;init-method&lt;/code&gt;属性会自动调用其配置的初始化方法&lt;/li&gt;
    &lt;li&gt;如果这个Bean关联了&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口，将会调用&lt;code&gt;postProcessAfterInitialization(Object obj, String s)&lt;/code&gt;方法&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在已经可以使用这个bean了, 使用完就可以准备清理了&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;当Bean不再需要时，会经过清理阶段，如果Bean实现了&lt;code&gt;DisposableBean&lt;/code&gt;这个接口，会调用那个其实现的&lt;code&gt;destroy()&lt;/code&gt;方法&lt;/li&gt;
    &lt;li&gt;最后，如果这个Bean的Spring配置中配置了&lt;code&gt;destroy-method&lt;/code&gt;属性，会自动调用其配置的销毁方法。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;--spring中有哪三种依赖注入的方式&quot;&gt;- Spring中有哪三种依赖注入的方式？&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;根据属性注入也叫set方法注入&lt;/li&gt;
  &lt;li&gt;根据构造方法注入&lt;/li&gt;
  &lt;li&gt;根据注解进行注入（推荐）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--spring事务的传播属性是怎么回事&quot;&gt;- Spring事务的传播属性是怎么回事&lt;/h2&gt;
&lt;h3 id=&quot;事务传播属性&quot;&gt;&lt;strong&gt;事务传播属性&lt;/strong&gt;　&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。&lt;/li&gt;
  &lt;li&gt;PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行&lt;/li&gt;
  &lt;li&gt;PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。&lt;/li&gt;
  &lt;li&gt;PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。&lt;/li&gt;
  &lt;li&gt;PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/li&gt;
  &lt;li&gt;PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。&lt;/li&gt;
  &lt;li&gt;PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务,则进行与PROPAGATION_REQUIRED类似的操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;事务隔离级别&quot;&gt;&lt;strong&gt;事务隔离级别&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;DEFAULT&lt;/li&gt;
  &lt;li&gt;UNCOMMITTED  这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。&lt;/li&gt;
  &lt;li&gt;COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。&lt;/li&gt;
  &lt;li&gt;READ  这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)&lt;/li&gt;
  &lt;li&gt;SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--spring主要组件&quot;&gt;- Spring主要组件&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;前端控制器组件（DispatcherServlet）&lt;/li&gt;
  &lt;li&gt;处理器组件（Controller）&lt;/li&gt;
  &lt;li&gt;处理器映射器组件（HandlerMapping）&lt;/li&gt;
  &lt;li&gt;处理器适配器组件（HandlerAdapter）&lt;/li&gt;
  &lt;li&gt;拦截器组件（HandlerInterceptor）&lt;/li&gt;
  &lt;li&gt;视图解析器组件（ViewResolver）&lt;/li&gt;
  &lt;li&gt;视图组件（View）&lt;/li&gt;
  &lt;li&gt;数据转换组件（DataBinder）&lt;/li&gt;
  &lt;li&gt;消息转换器组件（HttpMessageConverter）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--spring中beanfactory和factorybean有什么区别&quot;&gt;- Spring中BeanFactory和FactoryBean有什么区别？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;BeanFactory，以Factory结尾，表示它是一个工厂类(接口)，用于管理Bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。&lt;/li&gt;
  &lt;li&gt;以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean&lt;T&gt;接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;amp;符号来获取。&lt;/T&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--spring框架中ioc的原理是什么&quot;&gt;- Spring框架中IOC的原理是什么&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IoC是&lt;code&gt;Inversion of Control&lt;/code&gt;的缩写&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;获得依赖对象的过程被反转了&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;其原理是基于面向对象(OO)设计原则&lt;/li&gt;
  &lt;li&gt;所有的组件都是被动的，所有的组件初始化和调用都由容器负责&lt;/li&gt;
  &lt;li&gt;组件处在一个容器当中，由容器负责管理&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控，即在一个类中调用另外一个类。这也就是所谓“控制反转”的概念所在：控制权由应用代码中转到了外部容器，控制权的转移，即所谓反转。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;--spring-如何实现数据库事务&quot;&gt;- Spring 如何实现数据库事务&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;编程式事务管理：需要手动编写代码，在实际开发中很少使用&lt;/li&gt;
  &lt;li&gt;声明式事务管理：
    &lt;ul&gt;
      &lt;li&gt;基于&lt;code&gt;TransactionProxyFactoryBean&lt;/code&gt;的方式，需要为每个进行事务管理的类做相应配置&lt;/li&gt;
      &lt;li&gt;基于AspectJ的XML方式，不需要改动类，在XML文件中配置好即可&lt;/li&gt;
      &lt;li&gt;基于注解的方式，配置简单，需要在业务层类中添加注解&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--mybatis编程步骤是什么样的&quot;&gt;- MyBatis编程步骤是什么样的&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;创建&lt;code&gt;SqlSessionFactory&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过&lt;code&gt;SqlSessionFactory&lt;/code&gt;创建&lt;code&gt;SqlSession&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过&lt;code&gt;sqlsession&lt;/code&gt;执行数据库操作&lt;/li&gt;
  &lt;li&gt;调用&lt;code&gt;session.commit()&lt;/code&gt;提交事务&lt;/li&gt;
  &lt;li&gt;调用&lt;code&gt;session.close()&lt;/code&gt;关闭会话&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;--使用mybatis的mapper接口调用时有哪些要求&quot;&gt;- 使用MyBatis的mapper接口调用时有哪些要求&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Mapper接口方法名和&lt;code&gt;mapper.xml&lt;/code&gt;中定义的每个sql的id相同&lt;/li&gt;
  &lt;li&gt;Mapper接口方法的输入参数类型和&lt;code&gt;mapper.xml&lt;/code&gt;中定义的每个sql 的&lt;code&gt;parameterType&lt;/code&gt;的类型相同&lt;/li&gt;
  &lt;li&gt;Mapper接口方法的输出参数类型和&lt;code&gt;mapper.xml&lt;/code&gt;中定义的每个sql的&lt;code&gt;resultType&lt;/code&gt;的类型相同&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Mapper.xml&lt;/code&gt;文件中的&lt;code&gt;namespace&lt;/code&gt;即是mapper接口的类路径&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;--springmvc工作流程&quot;&gt;- SpringMVC工作流程&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;用户发送请求至前端控制器&lt;code&gt;DispatcherServlet&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;收到请求调用&lt;code&gt;HandlerMapping&lt;/code&gt;处理器映射器&lt;/li&gt;
  &lt;li&gt;处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给&lt;code&gt;DispatcherServlet&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;调用&lt;code&gt;HandlerAdapter&lt;/code&gt;处理器适配器&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt;经过适配调用具体的处理器(Controller，也叫后端控制器)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Controller&lt;/code&gt;执行完成返回&lt;code&gt;ModelAndView&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt;将&lt;code&gt;controller&lt;/code&gt;执行结果&lt;code&gt;ModelAndView&lt;/code&gt;返回给&lt;code&gt;DispatcherServlet&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;将&lt;code&gt;ModelAndView&lt;/code&gt;传给&lt;code&gt;ViewReslover&lt;/code&gt;视图解析器&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ViewReslover&lt;/code&gt;解析后返回具体&lt;code&gt;View&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;根据View进行渲染视图（即将模型数据填充至视图中）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;响应用户&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--mybatis-和的区别是什么&quot;&gt;- MyBatis #{}和${}的区别是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;${}是变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--xml映射文件中除了常见的selectinsertupdaedelete标签之外还有哪些标签&quot;&gt;- Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;还有很多其他的标签，&lt;code&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;parameterMap&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;sql&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;include&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;selectKey&amp;gt;&lt;/code&gt;，加上动态sql的9个标签，&lt;code&gt;trim&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;where&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;set&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;foreach&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;if&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;when&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;otherwise&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;bind&lt;/code&gt;等，其中&lt;sql&gt;为sql片段标签，通过`&lt;include&gt;`标签引入sql片段，`&lt;selectKey&gt;`为不支持自增的主键生成策略标签。&lt;/selectKey&gt;&lt;/include&gt;&lt;/sql&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;--mybatis-分页原理&quot;&gt;- MyBatis 分页原理&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;--mybatis-分页插件的原理是什么&quot;&gt;- MyBatis 分页插件的原理是什么？&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;数据库相关&quot;&gt;数据库相关&lt;/h1&gt;

&lt;h2 id=&quot;--乐观锁和悲观锁的区别&quot;&gt;- 乐观锁和悲观锁的区别？&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--索引数据结构&quot;&gt;- 索引数据结构&lt;/h2&gt;
&lt;p&gt;MySQL官方对索引的定义为：&lt;strong&gt;索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;二叉树？？&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--如何优化数据库性能&quot;&gt;- 如何优化数据库性能&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;表的设计合理化(符合3NF)&lt;/li&gt;
  &lt;li&gt;添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]&lt;/li&gt;
  &lt;li&gt;分表技术(水平分割、垂直分割)&lt;/li&gt;
  &lt;li&gt;读写[写: update/delete/add]分离&lt;/li&gt;
  &lt;li&gt;存储过程 [模块化编程，可以提高速度]&lt;/li&gt;
  &lt;li&gt;对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]&lt;/li&gt;
  &lt;li&gt;mysql服务器硬件升级&lt;/li&gt;
  &lt;li&gt;定时的去清除不需要的数据,定时进行碎片整理(MyISAM)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;--数据库索引&quot;&gt;- 数据库索引&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;适合建立索引的列&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构&lt;/li&gt;
  &lt;li&gt;在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度&lt;/li&gt;
  &lt;li&gt;在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的&lt;/li&gt;
  &lt;li&gt;在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间&lt;/li&gt;
  &lt;li&gt;在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;不适合建立索引的列&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于那些在查询中很少使用或者参考的列不应该创建索引&lt;/li&gt;
  &lt;li&gt;对于那些只有很少数据值的列也不应该增加索引&lt;/li&gt;
  &lt;li&gt;对于那些定义为text, image和bit数据类型的列不应该增加索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性&lt;/li&gt;
  &lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因&lt;/li&gt;
  &lt;li&gt;可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义&lt;/li&gt;
  &lt;li&gt;在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间- 表字段的类型选择要恰当&lt;/li&gt;
  &lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加&lt;/li&gt;
  &lt;li&gt;索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大&lt;/li&gt;
  &lt;li&gt;当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--sql中索引不会被用到的几种情况&quot;&gt;- sql中索引不会被用到的几种情况&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;查询谓词没有使用索引的主要边界,换句话说就是select *，可能会导致不走索引。&lt;/li&gt;
  &lt;li&gt;单键值的b树索引列上存在null值，导致COUNT(*)不能走索引。&lt;/li&gt;
  &lt;li&gt;索引列上有函数运算，导致不走索引&lt;/li&gt;
  &lt;li&gt;隐式转换导致不走索引。&lt;/li&gt;
  &lt;li&gt;表的数据库小或者需要选择大部分数据，不走索引&lt;/li&gt;
  &lt;li&gt;cbo优化器下统计信息不准确，导致不走索引&lt;/li&gt;
  &lt;li&gt;！=或者&amp;lt;&amp;gt;(不等于），可能导致不走索引，也可能走 INDEX FAST FULL SCAN&lt;/li&gt;
  &lt;li&gt;表字段的属性导致不走索引，字符型的索引列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式，&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;--mybatis批量插入返回主键&quot;&gt;- Mybatis批量插入返回主键&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;
    keyProperty=&quot;id&quot;&amp;gt;
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;--mybatis中dao工作原理&quot;&gt;- MyBatis中Dao工作原理&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。&lt;/delete&gt;&lt;/update&gt;&lt;/insert&gt;&lt;/select&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--mybatis对象关系&quot;&gt;- MyBatis对象关系&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;association  一对一关联查询&lt;/li&gt;
  &lt;li&gt;collection  一对多关联查询&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;网络协议和网络编程&quot;&gt;网络协议和网络编程&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;redis等缓存系统中间件nosql一致性hash等&quot;&gt;Redis等缓存系统/中间件/NoSQL/一致性Hash等&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;设计模式与重构&quot;&gt;设计模式与重构&lt;/h1&gt;
&lt;h2 id=&quot;--单例模式&quot;&gt;- 单例模式？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;懒汉模式  …&lt;/li&gt;
  &lt;li&gt;饿汉模式  …&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--工厂模式&quot;&gt;- 工厂模式&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;--代理模式&quot;&gt;- 代理模式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;静态代理&lt;/li&gt;
  &lt;li&gt;动态代理&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数据结构与算法基础&quot;&gt;数据结构与算法基础&lt;/h1&gt;

&lt;h2 id=&quot;--集合&quot;&gt;- 集合&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;结构&lt;/strong&gt;
Collection
|Set            无序，不允许重复
||————HashSet：哈希表｜无序｜元素必须实现HashCode()｜
||————TreeSet：二差树｜自动排升序 
|List           有序，可以有重复元素。
||————ArrayList：动态数组｜　查询↑　
||————LinkedList：链表｜插入和删除↑
Map　都可以用来存放java对象
|————HashMap　异步　不是线程安全的　效率↑　允许空键值｜数组结合链表
|————Hashtable 同步　线程安全　效率↓&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Set和List对比&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ArrayList和LinkedList&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt;,是数组结构：少用与中间的增删。多用于查询，修改。每次增删元素顺序都会操作每个元素。
&lt;code&gt;LinkedList&lt;/code&gt;,是链表结构：多用于中间，开头增删。少用查询，修改。查询时会遍历大量元素。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;--hashmap&quot;&gt;- HashMap&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;特点
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;HashMap可以接受null键值和值，而Hashtable则不能&lt;/li&gt;
        &lt;li&gt;HashMap非synchronized&lt;/li&gt;
        &lt;li&gt;使用put()存储, 使用get(key)获取,put()方法在&lt;code&gt;AbstractHashedMap.class&lt;/code&gt;中实现,先获取hash,通过hashcode在entry中查找,&lt;code&gt;if (entry.hashCode == hashCode &amp;amp;&amp;amp; isEqualKey(key, entry.key))&lt;/code&gt;查找是否存在,没找到就插入一条&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;为什么string-interger这样的wrapper类适合作为键&quot;&gt;为什么String, Interger这样的wrapper类适合作为键？&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，都是final的，而且已经重写了equals()和hashCode()方法了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;--arraylist&quot;&gt;- ArrayList&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;排序&lt;/strong&gt;　
    &lt;ul&gt;
      &lt;li&gt;Collections.sort()&lt;/li&gt;
      &lt;li&gt;Collections.sort(list,comparator)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;--treeset&quot;&gt;- TreeSet&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;排序&lt;/strong&gt;　
    &lt;ul&gt;
      &lt;li&gt;Collections.sort()&lt;/li&gt;
      &lt;li&gt;Collections.sort(list,comparator)&lt;/li&gt;
      &lt;li&gt;自带排序&lt;/li&gt;
      &lt;li&gt;构造器定制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;--hashset&quot;&gt;- HashSet&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，更确切的说，HashSet中的元素，只是存放在了底层HashMap的key上， 而value使用一个static final的Object对象标识。因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;jvm&quot;&gt;JVM&lt;/h1&gt;
&lt;h2 id=&quot;--jvm内存结构&quot;&gt;- JVM内存结构&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Java堆（Heap）:
    &lt;ul&gt;
      &lt;li&gt;Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块,几乎所有的对象实例都在这里分配内存&lt;/li&gt;
      &lt;li&gt;Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。&lt;/li&gt;
      &lt;li&gt;如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;方法区（Method Area）
    &lt;ul&gt;
      &lt;li&gt;各个线程共享的内存区域,&lt;strong&gt;它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据&lt;/strong&gt;,别名&lt;strong&gt;Non-Heap（非堆）(永久代)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;程序计数器（Program Counter Register）
    &lt;ul&gt;
      &lt;li&gt;一块较小的内存空间&lt;/li&gt;
      &lt;li&gt;它的作用可以看做是当前线程所执行的字节码的行号指示器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JVM栈（JVM Stacks）
    &lt;ul&gt;
      &lt;li&gt;线程私有&lt;/li&gt;
      &lt;li&gt;它的生命周期与线程相同&lt;/li&gt;
      &lt;li&gt;每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/li&gt;
      &lt;li&gt;当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。&lt;/li&gt;
      &lt;li&gt;如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;本地方法栈（Native Method Stacks）
    &lt;ul&gt;
      &lt;li&gt;与虚拟机栈所发挥的作用是非常相似的&lt;/li&gt;
      &lt;li&gt;虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;开放性问题&quot;&gt;开放性问题&lt;/h1&gt;
</description>
                <link>http://canmel.github.io/2017/10/12/java%E9%97%AE%E7%AD%94</link>
                <guid>http://canmel.github.io/2017/10/12/java问答</guid>
                <pubDate>2017-10-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring使用实体接收参数异常</title>
                <description>&lt;h3 id=&quot;在spring中设置路由&quot;&gt;在spring中设置路由&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    @RequestMapping(value = &quot;&quot;, method = RequestMethod.GET)
    public String index(Model model, Menu menu) throws JsonProcessingException {
        menu.setStatus(Status.active);
        return super.index(model, menu);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;发出以下异常&quot;&gt;发出以下异常：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.meedesidy.jeedey.entity.Menu]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.meedesidy.jeedey.entity.Menu.&amp;lt;init&amp;gt;()
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:105) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.annotation.ModelAttributeMethodProcessor.createAttribute(ModelAttributeMethodProcessor.java:141) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor.createAttribute(ServletModelAttributeMethodProcessor.java:81) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.annotation.ModelAttributeMethodProcessor.resolveArgument(ModelAttributeMethodProcessor.java:101) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:158) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:128) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat-embed-websocket-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_144]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_144]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_144]
Caused by: java.lang.NoSuchMethodException: com.meedesidy.jeedey.entity.Menu.&amp;lt;init&amp;gt;()
	at java.lang.Class.getConstructor0(Class.java:3082) ~[na:1.8.0_144]
	at java.lang.Class.getDeclaredConstructor(Class.java:2178) ~[na:1.8.0_144]
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:102) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	... 54 common frames omitted

2017-10-10 23:06:42.591 DEBUG 5280 --- [nio-9090-exec-9] .m.m.a.ExceptionHandlerExceptionResolver : Resolving exception from handler [public java.lang.String com.meedesidy.jeedey.controllers.MenusController.index(org.springframework.ui.Model,com.meedesidy.jeedey.entity.Menu) throws com.fasterxml.jackson.core.JsonProcessingException]: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.meedesidy.jeedey.entity.Menu]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.meedesidy.jeedey.entity.Menu.&amp;lt;init&amp;gt;()
2017-10-10 23:06:42.591 DEBUG 5280 --- [nio-9090-exec-9] .w.s.m.a.ResponseStatusExceptionResolver : Resolving exception from handler [public java.lang.String com.meedesidy.jeedey.controllers.MenusController.index(org.springframework.ui.Model,com.meedesidy.jeedey.entity.Menu) throws com.fasterxml.jackson.core.JsonProcessingException]: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.meedesidy.jeedey.entity.Menu]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.meedesidy.jeedey.entity.Menu.&amp;lt;init&amp;gt;()
2017-10-10 23:06:42.591 DEBUG 5280 --- [nio-9090-exec-9] .w.s.m.s.DefaultHandlerExceptionResolver : Resolving exception from handler [public java.lang.String com.meedesidy.jeedey.controllers.MenusController.index(org.springframework.ui.Model,com.meedesidy.jeedey.entity.Menu) throws com.fasterxml.jackson.core.JsonProcessingException]: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.meedesidy.jeedey.entity.Menu]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.meedesidy.jeedey.entity.Menu.&amp;lt;init&amp;gt;()
2017-10-10 23:06:42.593 DEBUG 5280 --- [nio-9090-exec-9] o.s.web.servlet.DispatcherServlet        : Could not complete request


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;原因&quot;&gt;原因&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;要在spring中使用实体来接收参数，必须至少有一个默认的构造器&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个类中如果不设置不写任何带参数的构造器,java 默认其带一个无参构造器
如果一个java类中已经有一个或一个以上的带参构造器,jvm不会给这个类添加默认的无参构造器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;所以我是因为在Menu.java中没有默认的构造器,造成一个实例化异常&lt;code&gt;BeanInstantiationException&lt;/code&gt;,&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;No default constructor found&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;解决思路&quot;&gt;解决思路&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;使用jvm默认提供的构造器,删除目标类(Menu.java)中所有带参构造&lt;/li&gt;
  &lt;li&gt;保留自己定义的构造器,增加一个无参构造器&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://canmel.github.io/2017/10/10/Spring%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8</link>
                <guid>http://canmel.github.io/2017/10/10/Spring使用实体接收参数异常</guid>
                <pubDate>2017-10-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>微信朋友圈分享案例</title>
                <description>&lt;blockquote&gt;
  &lt;p&gt;微信朋友圈分享或者分享给其他好友,如果需要自定义的&lt;code&gt;title&lt;/code&gt;, &lt;code&gt;desc&lt;/code&gt;, &lt;code&gt;image&lt;/code&gt;等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-前提&quot;&gt;1. 前提&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;微信公众平台&lt;code&gt;公众号设置&lt;/code&gt;中按提示设置&lt;code&gt;JS接口安全域名&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;获取开发者&lt;code&gt;ID(AppID)&lt;/code&gt;, &lt;code&gt;开发者密码(AppSecret)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;微信公众号中-&lt;code&gt;开发&lt;/code&gt;-&lt;code&gt;基本配置&lt;/code&gt;-&lt;code&gt;IP白名单&lt;/code&gt;中按提示设置要分享的页面的域名&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-代码&quot;&gt;2. 代码&lt;/h2&gt;

&lt;h3 id=&quot;js部分&quot;&gt;js部分&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script src=&quot;js/jquery-1.11.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(function () {
        $.ajax({
                url: &quot;http://xxxxxxxxx.json&quot;,       //获取签名
                async: false, //　设置同步，去服务器取到数据后设置微信js配置
                data: &quot;url=&quot; + encodeURIComponent(location.href.split('#')[0]),
                success: function (data) {
                    // 数据返回后注入微信的配置
                    wx.config({
                        debug: false,
                        appId: data[&quot;appid&quot;],
                        timestamp: data[&quot;timestamp&quot;],
                        nonceStr: data[&quot;nonceStr&quot;],
                        signature: data[&quot;signature&quot;],
                        jsApiList: ['onMenuShareTimeline','onMenuShareAppMessage'] // 功能列表，我们要使用JS-SDK的什么功能
                    });
                }
            });
         wx.ready(function () {
            wxshare();
            document.getElementById('bgmusic').play();
            bindSlide();
        });
    });
    
//    分享的配置（回调函数）
    function wxshare() {
        var shareData = {
            imgUrl:'http://www...........png',
            link:window.location.href.split('#')[0],
            title:'xxxxxxxxtitle?',
            desc:'xxxxxxxxdesc',
            success:function (res) {
                alert('已分享')
            },
            fail:function (res) {
                alert(JSON.stringify(res));
            }
        };
//        设置分享的类型
        wx.onMenuShareAppMessage(shareData);
        wx.onMenuShareTimeline(shareData);
    }
    
    
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;服务器部分&quot;&gt;服务器部分&lt;/h3&gt;

&lt;h4 id=&quot;ruby&quot;&gt;ruby&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  APPID = &quot;xxxxxxxxxxxxxappid&quot;.freeze
  APPSECRET = &quot;xxxxxxxxxxxxxxxxappsecret&quot;.freeze
  MAX_WAIT_TIME = 1.hour
  # 获取签名等信息
  def signature
    # 获取ticket
    ticket = get_ticket(get_token)
    # 获取以str开头＋100000以内随机数的随机字符串
    noncestr = &quot;str#{rand(99999)}&quot;
    # 时间戳
    timestamp = Time.now.to_i
    # 签名
    signature = get_signature(ticket, timestamp, params[:url], noncestr)
    # 允许跨域
    response.set_header('Access-Control-Allow-Origin', &quot;*&quot;)
    # 返回json
    respond_to do |format|
      format.json do
        render json: { ticket: ticket, nonceStr: noncestr, appid: APPID, signature: signature, timestamp: timestamp }
      end
    end
  end

  private

# uri请求　和　加密
  require &quot;open-uri&quot;
  require 'digest/sha1'

# 获取加密签名
  def get_signature(ticket, timestamp, url, noncestr)
    signaturestr = &quot;jsapi_ticket=#{ticket}&amp;amp;noncestr=#{noncestr}&amp;amp;timestamp=#{timestamp}&amp;amp;url=#{url}&quot;
    Digest::SHA1.hexdigest(signaturestr)
  end

# 微信api通过appid和appsecret获取token
# 这个获取token的接口每天每个账户调取次数有限，一定要缓存下来
  def get_token
    if Redis::Value.new(&quot;access_token&quot;, expiration: MAX_WAIT_TIME).value.nil?
      uri = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=#{APPID}&amp;amp;secret=#{APPSECRET}&quot;
      html_response = nil
      open(uri) do |http|
        html_response = http.read
      end
      access_token = JSON.parse(html_response)[&quot;access_token&quot;]
      Redis::Value.new(&quot;access_token&quot;, expiration: MAX_WAIT_TIME).value = access_token
    else
      Redis::Value.new(&quot;access_token&quot;, expiration: MAX_WAIT_TIME).value
    end
  end

# 微信api通过appid和appsecret获取ticket
# 这个获取ticket的接口每天每个账户调取次数有限，一定要缓存下来
  def get_ticket(token)
    if Redis::Value.new(&quot;ticket&quot;, expiration: MAX_WAIT_TIME).value.nil?
      String url = &quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&quot; + token + &quot;&amp;amp;type=jsapi&quot;
      html_response = nil
      open(url) do |http|
        html_response = http.read
      end
      ticket = JSON.parse(html_response)[&quot;ticket&quot;]
      Redis::Value.new(&quot;ticket&quot;, expiration: MAX_WAIT_TIME).value = ticket
    else
      Redis::Value.new(&quot;ticket&quot;, expiration: MAX_WAIT_TIME).value
    end
  end

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;java&quot;&gt;JAVA&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public Map&amp;lt;String,String&amp;gt; getSignature(HttpServletRequest request) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        String url = request.getParameter(&quot;url&quot;);
        Map&amp;lt;String,String&amp;gt; map = new HashMap&amp;lt;String,String&amp;gt;();
        String signature = &quot;&quot;;
        HttpSession session = request.getSession();
        Object sessionTicket = session.getAttribute(&quot;ticket&quot;);
        Object ticketTime = session.getAttribute(&quot;ticketTime&quot;);
        int i = (int)(Math.random()*10000);
        String nonceStr = &quot;skio&quot;+ i;
        String timestamp = Long.toString(System.currentTimeMillis() );
        /**
         * session中存放的“ticket” 失效时间是7200秒
         * 当ticket失效存入新的ticket和时间戳
         */
        if(sessionTicket != null &amp;amp;&amp;amp; (System.currentTimeMillis() - Long.parseLong(ticketTime.toString())) &amp;lt;= 7200000L){
            signature = getSignature(sessionTicket.toString(),timestamp,url,nonceStr);
            map.put(&quot;ticket&quot;,sessionTicket.toString());
        }else{
            String token = getToken();
            String ticket = getTicket(token);
            map.put(&quot;ticket&quot;,ticket);
            signature = getSignature(ticket,timestamp,url,nonceStr);
            session.setAttribute(&quot;ticket&quot;,ticket);
            session.setAttribute(&quot;ticketTime&quot;,&quot;&quot;+System.currentTimeMillis());
        }
        /**
         *  将信息以键值对的方式传回去
         *  nonceStr ： 随机字符串
         *  timestamp ： 签名的时间戳
         *  signature ： 签名
         */
        map.put(&quot;nonceStr&quot;,nonceStr);
        map.put(&quot;appid&quot;,&quot;wx706149a49cc4708f&quot;);
        map.put(&quot;timestamp&quot;,timestamp);
        map.put(&quot;signature&quot;,signature);
        return map;
    }
    
        /**
     * 获取token
     * @return
     */
    private String getToken(){
        String url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=wx706149a49cc4708f&amp;amp;secret=6b6ec20c8dadf44d071cdef5dd554ab3&quot;;
        String token_json = HttpUtil.doGet(url,null);
        JSONObject json = new JSONObject(token_json);
        if(json.has(&quot;access_token&quot;)){
            String access_token = json.get(&quot;access_token&quot;).toString();
            return  access_token;
        }else{
            throw new BusinessException(&quot;获取token_json失败!URL = &quot;+url);
        }
    }
    /**
     * 获取ticket
     * @return
     */
    private String getTicket(String token){
        String url = &quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&quot;+token+&quot;&amp;amp;type=jsapi&quot;;
        String ticket_json = HttpUtil.doGet(url,null);
        JSONObject ticket_obj = new JSONObject(ticket_json);
        if(ticket_obj.get(&quot;errmsg&quot;).toString().equals(&quot;ok&quot;)){
            String ticket = ticket_obj.get(&quot;ticket&quot;).toString();
            return  ticket;
        }else {
            throw new BusinessException(&quot;获取ticket失败！&quot;);
        }
    }
    /**
     * 获取签名
     * @param ticket
     * @return
     */
    private String getSignature(String ticket,String timestamp,String url,String nonceStr) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String signatureStr = &quot;jsapi_ticket=&quot;+ticket+&quot;&amp;amp;noncestr=&quot;+nonceStr+&quot;&amp;amp;timestamp=&quot;+timestamp+&quot;&amp;amp;url=&quot;+url;
        MessageDigest crypt = MessageDigest.getInstance(&quot;SHA-1&quot;);
        crypt.reset();
        crypt.update(signatureStr.getBytes(&quot;UTF-8&quot;));
        String signature = byteToHex(crypt.digest());
        return signature;
    }
    private static String byteToHex(final byte[] hash) {
        Formatter formatter = new Formatter();
        for (byte b : hash)
        {
            formatter.format(&quot;%02x&quot;, b);
        }
        String result = formatter.toString();
        formatter.close();
        return result;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;zzzzz&quot;&gt;ZZZZZ｀｀｀&lt;/h3&gt;

</description>
                <link>http://canmel.github.io/2017/09/20/%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%88%86%E4%BA%AB%E6%A1%88%E4%BE%8B</link>
                <guid>http://canmel.github.io/2017/09/20/微信朋友圈分享案例</guid>
                <pubDate>2017-09-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>HTML 中 placeholder提示换行</title>
                <description>&lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;准备的H5界面是在微信中分享朋友圈的&lt;/li&gt;
  &lt;li&gt;在&lt;code&gt;textarea&lt;/code&gt;中&lt;code&gt;placeholder&lt;/code&gt;提示可能需要换行&lt;/li&gt;
  &lt;li&gt;下面要将&lt;code&gt;文本1&lt;/code&gt;,&lt;code&gt;文本2&lt;/code&gt;分两行显示&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;textarea id=&quot;TextArea1&quot; placeholder=&quot;文本1~ 文本2~&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;textarea id=&quot;TextArea1&quot; placeholder=&quot;文本1~&amp;amp;#13;&amp;amp;#10;文本2~&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上述代码即可实现换行&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;安卓手机完全可以实现换行操作，ios不支持&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;解决&quot;&gt;解决&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;添加js&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;js/jquery.watermark.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;textarea添加样式 &lt;code&gt;class=&quot;jq_watermark&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;textarea id=&quot;TextArea1&quot; class=&quot;jq_watermark&quot; placeholder=&quot;文本1~文本2~&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;在文本中添加标签&lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;textarea id=&quot;TextArea1&quot; class=&quot;jq_watermark&quot; placeholder=&quot;文本1~&amp;lt;br/&amp;gt;文本2~&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ok-解决了&quot;&gt;OK 解决了&lt;/h3&gt;

</description>
                <link>http://canmel.github.io/2017/09/19/HTML%E4%B8%ADplaceholder%E6%8F%90%E7%A4%BA%E6%8D%A2%E8%A1%8C</link>
                <guid>http://canmel.github.io/2017/09/19/HTML中placeholder提示换行</guid>
                <pubDate>2017-09-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu 基本配置</title>
                <description>&lt;p&gt;安装完ubuntu后的15件事
https://www.sysgeek.cn/15-things-to-do-after-installing-ubuntu-16-04-lts/&lt;/p&gt;

&lt;p&gt;rubymine破解 http://idea.qinxi1992.cn/&lt;/p&gt;

&lt;p&gt;安装docker
https://docs.docker.com/engine/installation/linux/ubuntulinux/
安装docker compose
https://docs.docker.com/compose/install/#alternative-install-options&lt;/p&gt;

&lt;p&gt;安装Redis
http://blog.fens.me/linux-redis-install/&lt;/p&gt;

&lt;p&gt;sogo输入法:
http://pinyin.sogou.com/linux/,
注意坑:http://blog.csdn.net/tao_627/article/details/24119037&lt;/p&gt;

&lt;p&gt;wps安装&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;下载 http://kdl.cc.ksosoft.com/wps-community/download/a21/wps-office_10.1.0.5672~a21_amd64.deb&lt;/li&gt;
  &lt;li&gt;安装字体库
&lt;code&gt;sudo apt-get install ttf-mscorefonts-installer&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;双击deb文件安装或者
&lt;code&gt;sudo  dpkg  -i  wps-office_10.1.0.5672~a21_amd64.deb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://canmel.github.io/2017/09/18/ubuntu-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE</link>
                <guid>http://canmel.github.io/2017/09/18/ubuntu-基本配置</guid>
                <pubDate>2017-09-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring boot 计划任务</title>
                <description>&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置类注解@EnableScheduling 开启对计划任务的支持,然后在要执行的计划任务方法上添加注解@Scheduled,声明这是一个计划任务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;@Scheduled&lt;/code&gt;支持多种类型的计划任务,包含&lt;code&gt;cron&lt;/code&gt; &lt;code&gt;fixDelay&lt;/code&gt; &lt;code&gt;fixRate&lt;/code&gt;等&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;h3 id=&quot;计划任务执行类&quot;&gt;计划任务执行类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class ScheduledTaskService {

	private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
	
	// @Scheduled 设置计划任务执行方式
	@Scheduled(fixedRate = 1000)
	public void reportCurrentTime() {
		System.out.println(&quot;每隔1秒执行一次 &quot; + dateFormat.format(new Date()));
	}
	
	@Scheduled(cron = &quot;0 0 13 ? * *&quot;)
	public void fixTimeExecution() {
		System.out.println(&quot;在指定时间 &quot; + dateFormat.format(new Date()) + &quot; 执行&quot;);

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置类&quot;&gt;配置类&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;@EnableScheduling 开启对注解类的支持&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Configuration
@ComponentScan(&quot;com.meedesidy.test_spring4.schedu&quot;)
@EnableScheduling
public class TaskSchedulerConfig {
	
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://canmel.github.io/2017/09/11/spring-boot-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1</link>
                <guid>http://canmel.github.io/2017/09/11/spring-boot-计划任务</guid>
                <pubDate>2017-09-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring boot 组合注解与元注解</title>
                <description>&lt;blockquote&gt;
  &lt;p&gt;　可以使用自定义的注解，使用多个注解组合成一个组合注解，这样我们只需要一个注解就可以表示两个注解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;h3 id=&quot;组合注解&quot;&gt;组合注解&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
@ComponentScan
public @interface WiselyConfigration {

	String[] value() default {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;使用组合注解&quot;&gt;使用组合注解&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@WiselyConfigration(&quot;com.meedesidy.test_spring4.annotation&quot;)
public class DemoConfig {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用新的注解依然可以在容器中加入bean&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void main( String[] args ) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DemoConfig.class);
        DemoService demoService = context.getBean(DemoService.class);
        demoService.outputResult();
        context.close();
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://canmel.github.io/2017/09/11/spring-boot-%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%85%83%E6%B3%A8%E8%A7%A3</link>
                <guid>http://canmel.github.io/2017/09/11/spring-boot-组合注解与元注解</guid>
                <pubDate>2017-09-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring boot 条件注解</title>
                <description>&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过活动的profile可以获得不同的bean, Spring 4提供了一个通用的基于条件的Bean 的创建, 即使用@Conditional注解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;h3 id=&quot;判定条件定义&quot;&gt;判定条件定义&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class LinuxCondition implements Condition {
	@Override
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		return context.getEnvironment().getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class WindowsCondition implements Condition {
	@Override
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		return context.getEnvironment().getProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;不同条件下的bean&quot;&gt;不同条件下的Bean&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface ListService {
	public String showListCmd();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class LinuxListService implements ListService {

	@Override
	public String showListCmd() {
		return &quot;ls&quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class WindowsListService implements ListService{

	@Override
	public String showListCmd() {
		return &quot;dir&quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class ConditionConfig {

	@Bean
	@Conditional(WindowsCondition.class) // WindowsCondition 中 matches 返回true 则使用这个bean 
	public ListService windowsListService() {
		return new WindowsListService();
	}
	
	@Bean
	@Conditional(LinuxCondition.class) // WindowsCondition 中 matches 返回true 则使用这个bean
	public ListService linuxListService() {
		return new LinuxListService();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void main( String[] args ) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConditionConfig.class);
        ListService listService = context.getBean(ListService.class);
        System.out.println(context.getEnvironment().getProperty(&quot;os.name&quot;) + &quot;系统下的列表命令:　&quot; + listService.showListCmd());
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://canmel.github.io/2017/09/11/spring-boot-%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3</link>
                <guid>http://canmel.github.io/2017/09/11/spring-boot-条件注解</guid>
                <pubDate>2017-09-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring boot 常用配置</title>
                <description>&lt;h1 id=&quot;spring-常用配置&quot;&gt;Spring 常用配置&lt;/h1&gt;

&lt;h2 id=&quot;bean的scope&quot;&gt;@Bean的&lt;code&gt;scope&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;描述Spring 容器如何新建Bean实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;实现-通过scope实现&quot;&gt;实现 通过@Scope实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Singleton     一个spring容器只有一个bean实例,默认为单例&lt;/li&gt;
  &lt;li&gt;Prototype     每次调用新建一个Bean&lt;/li&gt;
  &lt;li&gt;Request       Web项目给每一个 Http Request新建一个实例&lt;/li&gt;
  &lt;li&gt;Session       Web项目给每一个 Http Session新建一个实例&lt;/li&gt;
  &lt;li&gt;GlobalSession 只在portal应用中有用,给每一个Global Http Session 创建一个&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://canmel.github.io/2017/09/11/spring-boot-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE</link>
                <guid>http://canmel.github.io/2017/09/11/spring-boot-常用配置</guid>
                <pubDate>2017-09-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>spring boot 多线程</title>
                <description>&lt;blockquote&gt;
  &lt;p&gt;Spring 通过任务执行器（TaskExecutor）实现多线程和并发编程，使用&lt;code&gt;ThreadPoolTaskExecutor&lt;/code&gt;可实现一个基于线程池&lt;code&gt;TaskExecutor&lt;/code&gt;
通过&lt;code&gt;＠EnableAsync&lt;/code&gt;开启对异步任务的支持，并通过在实际执行的&lt;code&gt;Bean&lt;/code&gt;的方法中使用&lt;code&gt;＠Async&lt;/code&gt;注解其是一个&lt;code&gt;异步任务&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;h3 id=&quot;配置类&quot;&gt;配置类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Configuration
@ComponentScan(&quot;com.meedesidy.test_spring4.executor&quot;)
@EnableAsync
// 实现AsyncConfigurer 重写getAsyncExecutor, getAsyncUncaughtExceptionHandler
public class TaskExecutorConfig implements AsyncConfigurer{
    
    //配置一个基于线程池的Executor
	@Override
	public Executor getAsyncExecutor() {
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		executor.setCorePoolSize(5);
		executor.setMaxPoolSize(10);
		executor.setQueueCapacity(25);
		executor.initialize();
		return executor;
	}

	@Override
	public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
		return null;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;任务执行类&quot;&gt;任务执行类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class AsyncTaskService {

	@Async // @Async 定义在方法上,该方法是个异步方法,若在类上,该类下所有的方法都是异步方法
	public void executeAsyncTask(Integer i) {
		System.out.println(&quot;执行异步任务：&quot; + i);
	}
	
	@Async
	public void executeAsyncTaskPlus(Integer i) {
		System.out.println(&quot;执行异步任务 + 1: &quot; + (i + 1));
	}
}

&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://canmel.github.io/2017/09/11/spring-boot-%E5%A4%9A%E7%BA%BF%E7%A8%8B</link>
                <guid>http://canmel.github.io/2017/09/11/spring-boot-多线程</guid>
                <pubDate>2017-09-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>spring boot 事件</title>
                <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;　Spring Event为bean和bean之间通信提供了支持,当一个bean处理完一个,另一个bean做出相应的处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;流程&quot;&gt;流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;自定义事件, 继承 ApplicationEvent&lt;/li&gt;
  &lt;li&gt;定义事件监听,实现 ApplicationListener&lt;/li&gt;
  &lt;li&gt;使用容器发布&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;h3 id=&quot;定义事件&quot;&gt;定义事件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class DemoEvent extends ApplicationContextEvent {

	private static final long serialVersionUID = 1L;
	
	private String msg;
	
	public DemoEvent(ApplicationContext source, String msg) {
		super(source);
		this.msg = msg;
	}

	public String getMsg() {
		return msg;
	}

	public void setMsg(String msg) {
		this.msg = msg;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;定义监听&quot;&gt;定义监听&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Component
public class DemoListener implements ApplicationListener&amp;lt;DemoEvent&amp;gt;{

	@Override
	public void onApplicationEvent(DemoEvent event) {
		String msg = event.getMsg();
		System.out.println(&quot;我(bean-demo-listener)接收到了 bean-demoPublisher 发布的消息:　&quot; + msg);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;使用容器发布&quot;&gt;使用容器发布&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Component
public class DemoPublisher {
	@Autowired
	ApplicationContext applicationContext;
	
	public void publish(String msg) {
		applicationContext.publishEvent(new DemoEvent(applicationContext, msg));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void main( String[] args ) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EnventConfig.class);
        DemoPublisher demoPublisher = context.getBean(DemoPublisher.class);
        demoPublisher.publish(&quot;我在App-class发送一条消息&quot;);
        context.close();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;解释&quot;&gt;解释&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;使用容器发布&lt;/code&gt;注入容器;&lt;/li&gt;
  &lt;li&gt;容器中发布新建的事件&lt;code&gt;DemoEvent&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;事件监听&lt;/code&gt;,实现&lt;code&gt;ApplicationListener&lt;/code&gt;,重写&lt;code&gt;onApplicationEvent(DemoEvent event)&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;事件监听业务逻辑就在&lt;code&gt;onApplicationEvent&lt;/code&gt;中&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://canmel.github.io/2017/09/11/spring-boot-%E4%BA%8B%E4%BB%B6</link>
                <guid>http://canmel.github.io/2017/09/11/spring-boot-事件</guid>
                <pubDate>2017-09-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring 基础</title>
                <description>&lt;h1 id=&quot;spring-基础&quot;&gt;Spring 基础&lt;/h1&gt;

&lt;h2 id=&quot;spring-依赖注入&quot;&gt;Spring 依赖注入&lt;/h2&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;控制反转(ICO)和依赖注入(DI)在spring中概念是等同的，控制反转时通过依赖注入实现的，所谓依赖注入是容器负责创建对象和维护对象之间的依赖关系，而不是通过对象自己负责自己的创建和解决自己的依赖．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Spring IoC容器(ApplicationContext)负责创建Bean,并通过容器将功能类注入到你需要的Bean中&lt;/p&gt;

&lt;h3 id=&quot;创建和注入方式&quot;&gt;创建和注入方式&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;xml&lt;/code&gt;, &lt;code&gt;注解&lt;/code&gt;, &lt;code&gt;JAVA配置&lt;/code&gt;, &lt;code&gt;Groovy配置&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;声明bean的注解&quot;&gt;声明Bean的注解&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;@Component  没有明确的角色&lt;/li&gt;
  &lt;li&gt;@Service    在业务逻辑层（service）使用&lt;/li&gt;
  &lt;li&gt;@Repository 在数据访问层(Dao)使用&lt;/li&gt;
  &lt;li&gt;@Controller 控制层(controller)使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;注入bean的注解&quot;&gt;注入Bean的注解&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;@Autowired  Spring提供的注解&lt;/li&gt;
  &lt;li&gt;@Inject     JSR-330提供的注解&lt;/li&gt;
  &lt;li&gt;@Resource   JSR-250提供的注解
均可注释在&lt;code&gt;set&lt;/code&gt;方法或属性上&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;扫描注册bean&quot;&gt;扫描注册Bean&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;@Component(“com.xx.xxx”)  自动扫描包名下所有使用声明了&lt;code&gt;Bean&lt;/code&gt;的注解,并注册为&lt;code&gt;Bean&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@configuration    声明当前是一个配置类型, 相当于一个xml配置文件,表明这个类可能会有&lt;code&gt;Bean&lt;/code&gt;的注解,此处无需在使用包扫描,因为所有的Bean都在此类中定义了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;以上两种方式都会自动加载注释了声明了bean的注解到Spring容器中&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;aop&quot;&gt;AOP&lt;/h2&gt;

&lt;h3 id=&quot;概念-1&quot;&gt;概念&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;面向切面编程,相对于OOP面向对象编程
AOP的目的是为了解耦,让一组类共享相同的行为&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;aspectj-注解式切面编程&quot;&gt;AspectJ 注解式切面编程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@AspectJ&lt;/code&gt;    声明一个切面&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@After&lt;/code&gt;, &lt;code&gt;@Before&lt;/code&gt;, &lt;code&gt;@Around&lt;/code&gt;定义建言,可直接使用拦截规则为参数&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@PointCut&lt;/code&gt;   定义拦截规则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自定义注解&quot;&gt;自定义注解&lt;/h2&gt;

&lt;h3 id=&quot;示例代码&quot;&gt;示例代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Action {
	String name();
	String tesd();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;@Target(ElementType.METHOD)   表示该注解用于什么地方，可能的值在枚举类 ElemenetType&lt;/li&gt;
  &lt;li&gt;@Retention 表示在什么级别保存该注解信息, 可选&lt;code&gt;RetentionPolicy&lt;/code&gt;内的枚举类型&lt;/li&gt;
  &lt;li&gt;@Documented 将此注解包含在 javadoc 中它代表着此注解会被javadoc工具提取成文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bean的scope&quot;&gt;@Bean的&lt;code&gt;scope&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&quot;概念-2&quot;&gt;概念&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;描述Spring 容器如何新建Bean实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;实现-通过scope实现&quot;&gt;实现 通过@Scope实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Singleton     一个spring容器只有一个bean实例,默认为单例&lt;/li&gt;
  &lt;li&gt;Prototype     每次调用新建一个Bean&lt;/li&gt;
  &lt;li&gt;Request       Web项目给每一个 Http Request新建一个实例&lt;/li&gt;
  &lt;li&gt;Session       Web项目给每一个 Http Session新建一个实例&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GlobalSession 只在portal应用中有用,给每一个Global Http Session 创建一个&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;需要注入的类&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
@Scope(&quot;prototype&quot;) // 每次调用创建一个实例
public class DemoPrototypeService {

}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://canmel.github.io/2017/09/11/Spring-%E5%9F%BA%E7%A1%80</link>
                <guid>http://canmel.github.io/2017/09/11/Spring 基础</guid>
                <pubDate>2017-09-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>spring cloud stream 消息驱动微服务</title>
                <description>
&lt;h2 id=&quot;依赖&quot;&gt;依赖&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-cloud-starter-stream-rabbit&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;接收消息&quot;&gt;接收消息&lt;/h2&gt;

&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;SinkReceiver.class&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
* @EnableBinding 指定一个或多个定义了@Input或@Output注解的接口
* 以此实现对消息通道(Channel)的绑定
* Sink.class 是Spring Cloud Stream 默认实现对输入消息绑定的定义
* @Input或@Output注释的会自动加入spring容器，可以直接注入
*/
@EnableBinding(value = {Sink.class})
public class SinkReceiver {
	
	private static Logger logger =                           LoggerFactory.getLogger(MeedStreamApplication.class);
     
     /**
     * @StreamListener被注释的方法注册为消息中心中间件上数据流的时间监听器
     * 注解中的属性值对应监听的消息通道名
     */
	@StreamListener(Sink.INPUT)
	public void receiver(Object payload ) {
		logger.info(&quot;Received : &quot; + payload);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;＃＃ 对应`RabbitMQ` 上`exchanges(消息交换机)`的name, 这里将设置为`test`　
spring.cloud.stream.bindings.sendoutput.destination=test

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;发送消息&quot;&gt;发送消息&lt;/h2&gt;

&lt;h3 id=&quot;代码-1&quot;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@EnableBinding(value = {Sender.class})
public class SinkSender {
	private static Logger logger = LoggerFactory.getLogger(SinkSender.class);

    @Bean
	@InboundChannelAdapter(value = Sender.SENDER, poller = @Poller(fixedDelay = &quot;2000&quot;))
	public MessageSource&amp;lt;String&amp;gt; timerMessageSource(){
		return () -&amp;gt; new GenericMessage&amp;lt;&amp;gt;(&quot;xxxxxxx2秒调用一次&quot;);
	}
}	

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;配置-1&quot;&gt;配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;＃＃ 对应`RabbitMQ` 上`exchanges(消息交换机)`的name, 这里将设置为`test`
＃＃ 可以不进行设置，但要使得消息交换机名称和之前的`test`一致才能接收消息，
＃＃ 两种方式:
＃＃ １．@StreamListener `参数` 与 前面的`test`一致
＃＃ ２．设置如下参数改变当前要接入的消息交换机`name`
spring.cloud.stream.bindings.receiverinput.destination=test

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@EnableBinding : 绑定消息通道（channel）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@StreamListener : 注册监听&lt;/strong&gt;&lt;/p&gt;
</description>
                <link>http://canmel.github.io/2017/09/03/spring-cloud-stream-%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1</link>
                <guid>http://canmel.github.io/2017/09/03/spring-cloud-stream-消息驱动微服务</guid>
                <pubDate>2017-09-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>spring cloud config 分布式配置中心</title>
                <description>
&lt;h1 id=&quot;spring-cloud-config-分布式配置中心&quot;&gt;spring cloud config 分布式配置中心&lt;/h1&gt;

&lt;p&gt;之前跟着&lt;code&gt;spring cloud 微服务实战&lt;/code&gt;做分布式配置中心，一直报&lt;code&gt;环境仓库&lt;/code&gt;, 注入失败的问题,记录下现在的成功项目现状&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3 id=&quot;1-文件结构&quot;&gt;1. 文件结构&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[X] &lt;strong&gt;config&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;[X]  &lt;strong&gt;src/main/java&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;[X] &lt;strong&gt;com/meedesidy/config&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;[ ] ConfigApplication.class&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;[X]  &lt;strong&gt;src/main/resources&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;[ ] application.properties&lt;/li&gt;
          &lt;li&gt;[ ] bootstrap.properties&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;[X]  &lt;strong&gt;src/test/java&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;[X] &lt;strong&gt;com/meedesidy/cinfig&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;[ ] ConfigApplicationTest.class&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;[ ] pom.xml&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-依赖&quot;&gt;2. 依赖&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

	&amp;lt;groupId&amp;gt;com.skio&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;config&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

	&amp;lt;name&amp;gt;config&amp;lt;/name&amp;gt;
	&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

	&amp;lt;parent&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;1.5.6.RELEASE&amp;lt;/version&amp;gt;
		&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
	&amp;lt;/parent&amp;gt;

	&amp;lt;properties&amp;gt;
		&amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
		&amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
		&amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
		&amp;lt;spring-cloud.version&amp;gt;Dalston.SR3&amp;lt;/spring-cloud.version&amp;gt;
	&amp;lt;/properties&amp;gt;

	&amp;lt;dependencies&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
		&amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;

	&amp;lt;dependencyManagement&amp;gt;
		&amp;lt;dependencies&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
				&amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
				&amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
				&amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
			&amp;lt;/dependency&amp;gt;
		&amp;lt;/dependencies&amp;gt;
	&amp;lt;/dependencyManagement&amp;gt;

	&amp;lt;build&amp;gt;
		&amp;lt;plugins&amp;gt;
			&amp;lt;plugin&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
				&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
			&amp;lt;/plugin&amp;gt;
		&amp;lt;/plugins&amp;gt;
	&amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3-添加注释&quot;&gt;3. 添加注释&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableConfigServer
public class ConfigApplication {
	public static void main(String[] args) {
		SpringApplication.run(ConfigApplication.class, args);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加&lt;code&gt;@SpringBootApplication&lt;/code&gt; 开启&lt;code&gt;Spring Cloud Config 服务端功能&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;4-添加配置&quot;&gt;4. 添加配置&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;application.properties&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-properties&quot;&gt;server.port=8888

spring.cloud.config.label=master
spring.cloud.config.server.git.uri=https://github.com/Canmel/spring-cloud-config/
spring.cloud.config.server.git.uri.username=892379244@qq.com
spring.cloud.config.server.git.uri.password=xxxxxx
spring.cloud.config.server.git.uri.search-paths=xxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;配置说明&quot;&gt;配置说明&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;spring.cloud.config.server.git.uri&lt;/code&gt;: Git仓库位置&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;spring.cloud.config.server.git.uri.username&lt;/code&gt;: Git用户名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;spring.cloud.config.server.git.uri.password&lt;/code&gt;: Git密码&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;spring.cloud.config.server.git.uri.search-paths&lt;/code&gt;: 仓库下相对位置，多个时以逗号分隔&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;5-填写仓库中实际配置信息&quot;&gt;5. 填写仓库中实际配置信息&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在git上的&lt;code&gt;search-paths&lt;/code&gt;路径下添加文件
    &lt;ul&gt;
      &lt;li&gt;meedesidy.properties&lt;/li&gt;
      &lt;li&gt;meedesidy-test.properties&lt;/li&gt;
      &lt;li&gt;meedesidy-dev.properties&lt;/li&gt;
      &lt;li&gt;meedesidy-prod.properties&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;search-paths&lt;/code&gt;路径下的文件添加对应内容
    &lt;ul&gt;
      &lt;li&gt;meedesidy.properties =&amp;gt; &lt;code&gt;from=meedesidy-default-1.0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;meedesidy-test.properties =&amp;gt; &lt;code&gt;from=meedesidy-test-1.0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;meedesidy-dev.properties =&amp;gt; &lt;code&gt;from=meedesidy-dev-1.0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;meedesidy-prod.properties =&amp;gt; &lt;code&gt;from=meedesidy-prod-1.0&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;切换分支&lt;code&gt;test-branch&lt;/code&gt;,修改&lt;code&gt;search-paths&lt;/code&gt;路径下的文件
    &lt;ul&gt;
      &lt;li&gt;meedesidy.properties =&amp;gt; &lt;code&gt;from=meedesidy-default-2.0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;meedesidy-test.properties =&amp;gt; &lt;code&gt;from=meedesidy-test-2.0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;meedesidy-dev.properties =&amp;gt; &lt;code&gt;from=meedesidy-dev-2.0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;meedesidy-prod.properties =&amp;gt; &lt;code&gt;from=meedesidy-prod-2.0&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;6-测试使用&quot;&gt;6. 测试使用&lt;/h3&gt;

&lt;h4 id=&quot;创建服务在pomxml添加下面的依赖&quot;&gt;①　创建服务，在&lt;code&gt;pom.xml&lt;/code&gt;添加下面的依赖&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;-创建bootstrapproperties&quot;&gt;② 　创建&lt;code&gt;bootstrap.properties&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;spring.application.name=meedesidy
spring.cloud.config.profile=dev
spring.cloud.config.label=master
spring.cloud.config.uri=http://localhost:8888

server.port=3001
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：客户端获得外部配置文件后加载到客户端ApplicationContext实例，该配置内容优先级高于客户端jar包内部的配置内容，所以jar包内重复的内容不在重复加载
如：　若&lt;code&gt;application.properties&lt;/code&gt;与&lt;code&gt;bootstrap.properties&lt;/code&gt;中都定义了项目名称，则以前者为准．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;-属性绑定valuefrom&quot;&gt;③ 　属性绑定@Value(“${from}”)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@RefreshScope
@RestController
Public class TestController{
	@Value(&quot;${from}&quot;)
	private String from;
	
	@RequestMapping(value = &quot;/from&quot;, method = RequestMethod.GET)
	public String from(){
	    return this.from;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;注入autowired&quot;&gt;④　注入@Autowired&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@RefreshScope
@RestController
Public class TestController{
    @Autowired
	private Environment env;
	
    @RequestMapping(value = &quot;environment&quot;, method = RequestMethod.GET)
	public String environment() {
		return env.getProperty(&quot;from&quot;, &quot;undefined&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：　&lt;code&gt;Environment&lt;/code&gt;在 &lt;code&gt;org.springframework.core.env.Environment&lt;/code&gt;,并不在cloud下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;启动访问&quot;&gt;⑤　启动访问&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;启动 &lt;code&gt;注册中心&lt;/code&gt;　&lt;/li&gt;
  &lt;li&gt;启动 &lt;code&gt;配置中心&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;启动 &lt;code&gt;meedesidy&lt;/code&gt;应用&lt;/li&gt;
  &lt;li&gt;访问　&lt;code&gt;localhost:3001/environment&lt;/code&gt;可以根据配置环境(profile)输出对应的&lt;code&gt;from&lt;/code&gt;属性值&lt;/li&gt;
  &lt;li&gt;访问　&lt;code&gt;localhost:3001/from&lt;/code&gt;可以根据配置环境(profile)输出对应的&lt;code&gt;from&lt;/code&gt;属性值&lt;/li&gt;
  &lt;li&gt;修改&lt;code&gt;git&lt;/code&gt;上的文件数据&lt;strong&gt;&lt;code&gt;不可以&lt;/code&gt;&lt;/strong&gt;实时更改&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;占位符配置uri&quot;&gt;占位符配置URI&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如：　spring.cloud.config.server.git.uri=https://github.com/Canmel/{application}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;{application}&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;spring cloud 会根据&lt;code&gt;spring.application.name&lt;/code&gt;填充占位符,从而动态获取配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;{profile}&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据&lt;code&gt;profile&lt;/code&gt;填充&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;{lebel}&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分支，如果分支名中出现’/’,在HTTP的URL中使用＂(_)＂来替代，避免改变URI含义&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;安全保护&quot;&gt;安全保护&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;敏感信息存放在未加密的微服务应用上是不安全的
配置中心加密方式有很多，由于spring cloud基于&lt;code&gt;spring boot&lt;/code&gt;与&lt;code&gt;Spring Security&lt;/code&gt; 结合使用会更加方便&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;配置spring-security&quot;&gt;配置&lt;code&gt;Spring Security&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;启动默认会在日志给出一个随机密码，一般不适用随机密码，由配置文件指定&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sucurity.user.name=meeedesidy
security.user.password=mypassword
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;客户端使用，在配置文件中添加配置（存在bootstrap.properties时，似乎在application.propeties中配置无效）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#-- bootstrap.properties 
spring.cloud.config.username=meedesidy
spring.cloud.config.password=mypassword
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;服务化配置中心&quot;&gt;服务化配置中心&lt;/h3&gt;
&lt;h4 id=&quot;配置中心&quot;&gt;配置中心&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;主类添加注释&lt;code&gt;@EnableDiscoveryClient&lt;/code&gt;,以获取被注册中心发现的能力．&lt;/li&gt;
  &lt;li&gt;配置文件,指明注册中心地址&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt; eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;客户端&quot;&gt;客户端&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;配置(添加对配置中心的需求及安全信息)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt;spring:
  cloud:
    config:
      username: meedesidy
      password: lidejian111
      discovery:
        enable: true
        serviceId: config-server
      profile: dev
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;主类添加注释&lt;code&gt;@EnableDiscoveryClient&lt;/code&gt;,以获取被注册中心发现的能力．&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${from}&quot;)
private String from;

@RequestMapping(&quot;/from&quot;)
public String from(){
    return from;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://canmel.github.io/2017/08/30/spring-cloud-config-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE</link>
                <guid>http://canmel.github.io/2017/08/30/spring-cloud-config-分布式配置</guid>
                <pubDate>2017-08-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>spring cloud RestTemplate 几种的请求</title>
                <description>
&lt;hr /&gt;

&lt;h3 id=&quot;get请求&quot;&gt;GET请求&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名&lt;/th&gt;
      &lt;th&gt;返回　&lt;/th&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;getForEntity&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;org.springframework.http.ResponseEntity&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Object&lt;/code&gt;… urlVariables&lt;/td&gt;
      &lt;td&gt;第三个参数是一个数组，顺序对应&lt;code&gt;url&lt;/code&gt;占位符顺序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;getForEntity&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;org.springframework.http.ResponseEntity&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType, Map uriVariables&lt;/td&gt;
      &lt;td&gt;url定义：　http://xxx.xxx?name={name}, map参数必须有一个key为&lt;code&gt;name&lt;/code&gt;的键值对&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;getForEntity&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;org.springframework.http.ResponseEntity&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType&lt;/td&gt;
      &lt;td&gt;使用一个统一资源标识符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;getForObject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自定义　&lt;code&gt;responseType&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Object&lt;/code&gt;… uriVariables&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;uriVariables&lt;/code&gt;为&lt;code&gt;url&lt;/code&gt;中占位符对应的参数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;getForObject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自定义　&lt;code&gt;responseType&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Map&lt;/code&gt; uriVariables&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;uriVariables&lt;/code&gt;为&lt;code&gt;url&lt;/code&gt;中占位符对应的参数,名称需要与&lt;code&gt;map&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;对应起来&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;getForObject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自定义　&lt;code&gt;responseType&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType&lt;/td&gt;
      &lt;td&gt;使用一个统一资源标识符&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;post请求&quot;&gt;POST请求&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名&lt;/th&gt;
      &lt;th&gt;返回　&lt;/th&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForEntity&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;org.springframework.http.ResponseEntity&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Object&lt;/code&gt;… urlVariables&lt;/td&gt;
      &lt;td&gt;第三个参数是一个数组，顺序对应&lt;code&gt;url&lt;/code&gt;占位符顺序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForEntity&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;org.springframework.http.ResponseEntity&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Map&lt;/code&gt; uriVariables&lt;/td&gt;
      &lt;td&gt;url定义：　http://xxx.xxx?name={name}, &lt;code&gt;map&lt;/code&gt;参数必须有一个key为&lt;code&gt;name&lt;/code&gt;的键值对&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForEntity&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;org.springframework.http.ResponseEntity&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Class&lt;/code&gt; responseType&lt;/td&gt;
      &lt;td&gt;使用一个统一资源标识符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForObject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自定义　&lt;code&gt;responseType&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Object&lt;/code&gt;… uriVariables&lt;/td&gt;
      &lt;td&gt;第三个参数是一个数组，顺序对应&lt;code&gt;url&lt;/code&gt;占位符顺序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForObject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自定义　&lt;code&gt;responseType&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Map&lt;/code&gt; uriVariables&lt;/td&gt;
      &lt;td&gt;url定义：　http://xxx.xxx?name={name}, &lt;code&gt;map&lt;/code&gt;参数必须有一个key为&lt;code&gt;name&lt;/code&gt;的键值对&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForObject&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;自定义　&lt;code&gt;responseType&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Class&lt;/code&gt; responseType&lt;/td&gt;
      &lt;td&gt;使用一个统一资源标识符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForLocation&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Object&lt;/code&gt;… uriVariables&lt;/td&gt;
      &lt;td&gt;第三个参数是一个数组，顺序对应&lt;code&gt;url&lt;/code&gt;占位符顺序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForLocation&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Map&lt;/code&gt; uriVariables&lt;/td&gt;
      &lt;td&gt;url定义：　http://xxx.xxx?name={name}, &lt;code&gt;map&lt;/code&gt;参数必须有一个key为&lt;code&gt;name&lt;/code&gt;的键值对&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;postForLocation&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request&lt;/td&gt;
      &lt;td&gt;使用一个统一资源标识符&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;put请求&quot;&gt;PUT请求&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名&lt;/th&gt;
      &lt;th&gt;返回　&lt;/th&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;put&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Object&lt;/code&gt;… urlVariables&lt;/td&gt;
      &lt;td&gt;第三个参数是一个数组，顺序对应&lt;code&gt;url&lt;/code&gt;占位符顺序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;put&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Class&lt;/code&gt; responseType, &lt;code&gt;Map&lt;/code&gt; uriVariables&lt;/td&gt;
      &lt;td&gt;url定义：　http://xxx.xxx?name={name}, &lt;code&gt;map&lt;/code&gt;参数必须有一个key为&lt;code&gt;name&lt;/code&gt;的键值对&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;put&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt; request, &lt;code&gt;Class&lt;/code&gt; responseType&lt;/td&gt;
      &lt;td&gt;使用一个统一资源标识符&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;delete请求&quot;&gt;DELETE请求&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名&lt;/th&gt;
      &lt;th&gt;返回　&lt;/th&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;put&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Object&lt;/code&gt;… urlVariables&lt;/td&gt;
      &lt;td&gt;第三个参数是一个数组，顺序对应&lt;code&gt;url&lt;/code&gt;占位符顺序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;put&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;String&lt;/code&gt; url, &lt;code&gt;Map&lt;/code&gt; uriVariables&lt;/td&gt;
      &lt;td&gt;url定义：　http://xxx.xxx?name={name}, &lt;code&gt;map&lt;/code&gt;参数必须有一个key为&lt;code&gt;name&lt;/code&gt;的键值对&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;put&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;URI&lt;/code&gt; url&lt;/td&gt;
      &lt;td&gt;使用一个统一资源标识符&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
                <link>http://canmel.github.io/2017/08/25/spring-cloud-resttemplate</link>
                <guid>http://canmel.github.io/2017/08/25/spring-cloud-resttemplate</guid>
                <pubDate>2017-08-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>java 8 新特性</title>
                <description>
&lt;h3 id=&quot;1-default方法defender方法&quot;&gt;1. default方法（defender方法）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public interface BaseInterface {
  public void doSomeWork();
}

class SimpleInterfaceImpl implements BaseInterface{
  @Override
  public void doSomeWork() {
    System.out.println(&quot;Do Some Work implementation in the class&quot;);
  }
 
  public static void main(String[] args) {
    SimpleInterfaceImpl simpObj = new SimpleInterfaceImpl();
    simpObj.doSomeWork();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要向上面的接口添加新方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface BaseInterface {
  public void doSomeWork();
  public void doSomeOtherWork();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行会得到&lt;code&gt;SimpleInterfaceImpl&lt;/code&gt; 不是一个抽象类或没有重写&lt;code&gt;doSomeOtherWork()&lt;/code&gt;这个抽象方法&lt;/p&gt;

&lt;p&gt;所以要直接改变/拓展一个接口内部方法变得困难,在尝试强化&lt;code&gt;java 8 Collections API&lt;/code&gt; 让其支持&lt;code&gt;lambda&lt;/code&gt;表达式的时候，就面临了这样的挑战,为了克服这个困难，&lt;code&gt;Java 8&lt;/code&gt;中引入了一个新的概念，叫做&lt;code&gt;default&lt;/code&gt;方法，也可以称为&lt;code&gt;Defender&lt;/code&gt;方法，或者&lt;code&gt;虚拟扩展方法&lt;/code&gt;（&lt;code&gt;Virtual extension methods)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如： in java.util&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;default void replaceAll(UnaryOperator&amp;lt;E&amp;gt; operator) {
    Objects.requireNonNull(operator);
    final ListIterator&amp;lt;E&amp;gt; li = this.listIterator();
    while (li.hasNext()) {
        li.set(operator.apply(li.next()));
    }
}

default void sort(Comparator&amp;lt;? super E&amp;gt; c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator&amp;lt;E&amp;gt; i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://canmel.github.io/2017/08/23/java-8-%E6%96%B0%E7%89%B9%E6%80%A7</link>
                <guid>http://canmel.github.io/2017/08/23/java-8-新特性</guid>
                <pubDate>2017-08-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring cloud application.properties</title>
                <description>
&lt;ul&gt;
  &lt;li&gt;server:
    &lt;ul&gt;
      &lt;li&gt;port:                 &lt;code&gt;服务端口&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;spring:
    &lt;ul&gt;
      &lt;li&gt;application:
        &lt;ul&gt;
          &lt;li&gt;name:             &lt;code&gt;服务名称，&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;eureka:
    &lt;ul&gt;
      &lt;li&gt;client:
        &lt;ul&gt;
          &lt;li&gt;serviceUrl:
            &lt;ul&gt;
              &lt;li&gt;defaultZone:  &lt;code&gt;服务注册中心地址&lt;/code&gt;
  为了安全很多时候都会为服务注册中心加上安全校验配置serviceUrl加上Url加上安全校验信息，比如&lt;code&gt;http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@localhost:1111/eureka/&lt;/code&gt;
  其中&lt;code&gt;username&lt;/code&gt;是安全校验信息用户名，&lt;code&gt;password&lt;/code&gt;为该用户的密码&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;register-with-eureka: &lt;code&gt;默认true, 启动时想注册机注册自己&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;fetch-registry:   &lt;code&gt;检索服务　默认true&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;registry-fetch-interval-seconds: &lt;code&gt;获取只读服务列表的时间间隔默认３０秒, 前提是fetch-registry　不为false&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;instance:
        &lt;ul&gt;
          &lt;li&gt;hostname:         &lt;code&gt;主机名&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;lease-renewal-interval-in-seconds: &lt;code&gt;服务续约任务的调用时间　默认30秒&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;lease-expiration-duration-in-seconds: &lt;code&gt;定义服务失效时间　默认90秒&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;server:
        &lt;ul&gt;
          &lt;li&gt;enable-self-preservation: &lt;code&gt;保护机制(检测实例心跳链接: 15分组低于85%)　默认true&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://canmel.github.io/2017/08/22/spring-cloud-applicationproperties</link>
                <guid>http://canmel.github.io/2017/08/22/spring-cloud-applicationproperties</guid>
                <pubDate>2017-08-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu安装java开发环境</title>
                <description>
&lt;h3 id=&quot;添加ppa更新&quot;&gt;添加ppa,更新&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;~ sudo add-apt-repository ppa:webupd8team/java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;~ sudo apt-get update&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###　安装oracle-java-installer&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jdk7
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo apt-get install oracle-java7-installer&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;jdk8
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo apt-get install oracle-java8-installer&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;安装器会提示你同意 oracle 的服务条款,选择 ok,然后选择yes 即可
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;设置系统默认jdk&quot;&gt;设置系统默认jdk&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JDk7
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-7-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;JDk8
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-8-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;切换jdk版本&quot;&gt;切换jdk版本&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;jdk8 切换到jdk7
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-7-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;jdk7 切换到jdk8
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-8-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;测试jdk-是是否安装成功&quot;&gt;测试jdk 是是否安装成功&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;~ java -version
~ javac -version&lt;/p&gt;
&lt;/blockquote&gt;

</description>
                <link>http://canmel.github.io/2017/08/21/ubuntu%E5%AE%89%E8%A3%85jdk</link>
                <guid>http://canmel.github.io/2017/08/21/ubuntu安装jdk</guid>
                <pubDate>2017-08-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>在阿里云服务器使用docker部署web项目</title>
                <description>&lt;h2 id=&quot;在阿里云服务器使用docker部署web项目&quot;&gt;在阿里云服务器使用docker部署web项目&lt;/h2&gt;
&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;github 帐号，创建新的&lt;code&gt;repository&lt;/code&gt;,并将代码push到这个&lt;code&gt;repository&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;阿里云服务器&lt;/li&gt;
  &lt;li&gt;注册&lt;code&gt;daocloud&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ssh登录远程服务器&quot;&gt;ssh登录远程服务器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;~ ssh root@99.99.99.99 &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安装docker&quot;&gt;安装docker&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;可以借鉴 &lt;a href=&quot;http://blog.csdn.net/mickjoust/article/details/51578629&quot;&gt;Ubuntu 16.04安装使用Docker &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###&lt;/p&gt;
</description>
                <link>http://canmel.github.io/2017/08/20/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8docker%E5%8F%91%E5%B8%83web%E9%A1%B9%E7%9B%AE</link>
                <guid>http://canmel.github.io/2017/08/20/阿里云服务器使用docker发布web项目</guid>
                <pubDate>2017-08-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Rails中的ActiveSupport</title>
                <description>&lt;h2 id=&quot;rails中的activesupport&quot;&gt;Rails中的ActiveSupport&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rails::Railtie is the core of the Rails framework and provides several hooks to extend Rails and/or modify the initialization process.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Rails::Railties 是Rails框架核心，并提供了几个钩子扩展Rails和/或修改初始化过程。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;得到gem&quot;&gt;得到gem&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;rails new appname&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Rails::Railties 是Rails框架核心,创建rails程序,&lt;code&gt;External Libraries&lt;/code&gt;　中会看到　&lt;code&gt;Railties&lt;/code&gt;的gem&lt;/p&gt;

&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;rails s&lt;/code&gt; , 是程序开始的地方&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先会执行　&lt;code&gt;RUBY_PATH/bin/rails&lt;/code&gt;, 具体是这个样子的：&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; #!/usr/bin/env ruby
 #
 # This file was generated by RubyGems.
 #
 # The application 'railties' is installed as part of a gem, and
 # this file is here to facilitate running it.
 #
    
 require 'rubygems'
    
 version = &quot;&amp;gt;= 0.a&quot;
    
 if ARGV.first
   str = ARGV.first
   str = str.dup.force_encoding(&quot;BINARY&quot;) if str.respond_to? :force_encoding
   if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
     version = $1
     ARGV.shift
   end
 end
    
 gem 'railties', version
 load Gem.bin_path('railties', 'rails', version)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着执行　&lt;code&gt;load Gem.bin_path('railties', 'rails', version)&lt;/code&gt;(文件在&lt;code&gt;RUBY_PATH/rubygems.rb&lt;/code&gt;), 加载gem包下可执行文件&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;加载的gem包含&lt;code&gt;ActiveSupport&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;ActiveSupport&lt;/code&gt;中定义了很多类和方法，如：　&lt;code&gt;lib/active_support/core_ext/object/blank.rb&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; class NilClass
   # +nil+ is blank:
   #
   #   nil.blank? # =&amp;gt; true
   #
   # @return [true]
   def blank?
     true
   end
 end
&lt;/code&gt;&lt;/pre&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;这样就可以得到&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;irb(main):001:0&amp;gt; nil.blank? =&amp;gt; true`&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://canmel.github.io/2017/07/17/Rails%E4%B8%AD%E7%9A%84ActiveSupport</link>
                <guid>http://canmel.github.io/2017/07/17/Rails中的ActiveSupport</guid>
                <pubDate>2017-07-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Rails中什么时候需要require</title>
                <description>&lt;h2 id=&quot;rails中什么时候需要require&quot;&gt;Rails中什么时候需要require&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Scene&lt;/code&gt;&lt;/strong&gt;  在现在的ROR开发中，比如在用户的控制器中使用下面一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class UsersController &amp;lt; ApplicationController
  def test
    p User.name
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Qustion&lt;/code&gt;&lt;/strong&gt; 然而在&lt;code&gt;Controller&lt;/code&gt;中并没有任何的&lt;code&gt;require&lt;/code&gt;或者&lt;code&gt;import&lt;/code&gt;或者&lt;code&gt;include&lt;/code&gt;等动作，那&lt;code&gt;User&lt;/code&gt;类是怎么加载到&lt;code&gt;controller&lt;/code&gt;中的呢？&lt;/p&gt;

&lt;h3 id=&quot;整理这个问题的时候我顺便找到了关于-ruby-内核类加载机制-&quot;&gt;整理这个问题的时候,我顺便找到了关于 &lt;a href=&quot;http://www.baidu.com&quot;&gt;Ruby 内核类加载机制 &lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;load_path&quot;&gt;$LOAD_PATH&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在&lt;code&gt;Rails&lt;/code&gt;项目中有很多第三方库，如果要对第三方库和业务代码进行管理，即&lt;code&gt;$LOAD_PATH&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Ruby&lt;/code&gt;并不要求统一管理类，理论上我们的类文件可以遍布整个系统各个角落，意味着我们需要为每个文件制定一个绝对路径活着相对路径&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$LOAD_PATH&lt;/code&gt;是一个字符串数组，元素是一堆路径
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt; $:
  =&amp;gt; [&quot;/home/baily/.rbenv/plugins/rbenv-gem-rehash&quot;, &quot;/home/baily/.rbenv/rbenv.d/exec/gem-rehash&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/did_you_mean-1.0.0/lib&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/site_ruby/2.3.0&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/site_ruby/2.3.0/x86_64-linux&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/site_ruby&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/vendor_ruby/2.3.0&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/vendor_ruby/2.3.0/x86_64-linux&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/vendor_ruby&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/2.3.0&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/2.3.0/x86_64-linux&quot;]
  irb(main):002:0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;这样就可以很方便对类库进行管理，和新类库的添加
    &lt;blockquote&gt;
      &lt;p&gt;$:.unshift File.dirname(&lt;strong&gt;FILE&lt;/strong&gt;) //添加新路径&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ruby-kernel-中的类加载&quot;&gt;Ruby Kernel 中的类加载&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Ruby 内核提供了 4 个类加载命令，分别是 load, autoload, require, require_relative, 分别对应了不同的使用场景&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;load(filename, wrap=false):&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;每次重新加载整个文件，成功返回true,失败抛出异常，wrap为true时，被加载文件会在一个匿名模块中执行，避免污染；&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;autoload(module, filename):&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;将filename与module关联，当第一次使用module时，使用require加载该文件;成功返回nil,失败抛出异常&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;require(name):
    &lt;blockquote&gt;
      &lt;p&gt;函数执行时，如果name是绝对路径，则会去查找该文件；通常name是相对路径，需要$:.unshift添加搜索路径；,Ruby会在$:中的目录中搜索该文件,第一次加载返回true，已经加载返回false，找不到文件会抛出LoadError&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;require_relative(filename):
    &lt;blockquote&gt;
      &lt;p&gt;直接取相对路径。此时与$LOAD_PATH($:)无关，是文件本身路径的相对地址&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;activesupport-对内核类加载的扩展&quot;&gt;ActiveSupport 对内核类加载的扩展&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Active Support 是 Rails 裡的工具函式庫，它也擴充了一些 Ruby 標準函式庫。除了被用在 Rails 核心程式中，你也可以在你的程式中使用&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;autoload-扩展&quot;&gt;autoload 扩展&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;除了&lt;code&gt;ActiveSupport&lt;/code&gt;对gem的扩展，在&lt;code&gt;Rails&lt;/code&gt;中，维护了一个类似&lt;code&gt;$LOAD_PATH&lt;/code&gt;的变量&lt;code&gt;autoload_paths&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rails 3 中默认会将 &lt;code&gt;app&lt;/code&gt; 下的子目录以及 lib 目录全部加入 &lt;code&gt;autoload_paths&lt;/code&gt;, Rails 4 中去掉了 lib.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以下是一个刚生成的 Rails 3 项目的 &lt;code&gt;autoload&lt;/code&gt; 路径:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ bin/rails r 'puts ActiveSupport::Dependencies.autoload_paths'
  .../app/assets
  .../app/controllers
  .../app/helpers
  .../app/mailers
  .../app/models
  .../app/controllers/concerns
  .../app/models/concerns
  .../test/mailers/previews
  .../lib
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Rails 中还可以添加自定义的 autoload 路径:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  # config/application.rb
  config.autoload_paths &amp;lt;&amp;lt; &quot;#{Rails.root}/something&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;autoload_paths&lt;/code&gt; 实际上是在 &lt;code&gt;ActiveSupport::Dependencies.autoload_paths&lt;/code&gt; 中定义的, 这是一个 &lt;code&gt;String Array&lt;/code&gt;, 可见 &lt;code&gt;Rails&lt;/code&gt; 的 &lt;code&gt;autoload&lt;/code&gt; 本质上是 &lt;code&gt;ActiveSupport&lt;/code&gt; 的 &lt;code&gt;autoload&lt;/code&gt; 机制&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以下代码将当前目录加入&lt;code&gt;autoload_paths&lt;/code&gt;, 这样在&lt;code&gt;Ruby&lt;/code&gt;找不到某个常量定义的时候，&lt;code&gt;ActiveSupport&lt;/code&gt;就会尝试找到常量定义文件并自动加载.
    &lt;pre&gt;&lt;code&gt;  ActiveSupport::Dependencies.autoload_paths &amp;lt;&amp;lt; '.'
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;到这里&lt;code&gt;rails&lt;/code&gt;项目中就可以在业务代码中互相访问了, 在&lt;code&gt;autoload_path&lt;/code&gt;中没有包含的路径，则需要添加&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;查询&lt;code&gt;autoload_path&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;bin/rails r ‘puts ActiveSupport::Dependencies.autoload_paths’ # 查询autoload_path&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;添加&lt;code&gt;autoload_path&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;config.autoload_paths « ”#{Rails.root}/something” # 添加autoload_path&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;也可以在代码中添加&lt;code&gt;require&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;require ‘../test.rb’ # 如果name是绝对路径，则会去查找该文件；通常name是相对路径，需要$:.unshift添加搜索路径；&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Answer&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;User&lt;/code&gt;加载到&lt;code&gt;UsersController&lt;/code&gt;是通过&lt;code&gt;Rails&lt;/code&gt;的扩展库&lt;code&gt;ActiveSupport&lt;/code&gt;维护的一个类似&lt;code&gt;$LOAD_PATH&lt;/code&gt;的一个变量&lt;code&gt;autoload_path&lt;/code&gt;管理文件的&lt;code&gt;load&lt;/code&gt;之类的行为,他默认路径包含&lt;code&gt;app/&lt;/code&gt;之下的几个文件夹(受rails版本，可能不相同)，&lt;code&gt;/controller&lt;/code&gt;和&lt;code&gt;model&lt;/code&gt;在其中，所以可以在&lt;code&gt;controller&lt;/code&gt;中访问&lt;code&gt;model&lt;/code&gt;信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;也就是说在&lt;code&gt;rails3&lt;/code&gt;以下路径下都是不用&lt;code&gt;include&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;这类行为，就可以使用
    &lt;pre&gt;&lt;code&gt;  .../app/assets
  .../app/controllers
  .../app/helpers
  .../app/mailers
  .../app/models
  .../app/controllers/concerns
  .../app/models/concerns
  .../test/mailers/previews
  .../lib
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;而在&lt;code&gt;autoload_path&lt;/code&gt;中不包含的路径就需要手动&lt;code&gt;require&lt;/code&gt;,像这样：
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  ## Rails 5
  class UsersController &amp;lt; ApplicationController::Base
    # rails的autoload没有lib的路径
    # $LOAD_PATH中 $: 中有lib的路径，所以不需要require全路径
    require 'util/myutil'
  end
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://canmel.github.io/2017/07/17/Rails%E4%B8%AD%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E9%9C%80%E8%A6%81require</link>
                <guid>http://canmel.github.io/2017/07/17/Rails中什么地方需要require</guid>
                <pubDate>2017-07-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ruby中String和symbol的区别</title>
                <description>&lt;h2 id=&quot;ruby中string和symbol的区别&quot;&gt;ruby中String和symbol的区别&lt;/h2&gt;
&lt;h3 id=&quot;symbol&quot;&gt;Symbol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;定义：Ruby 是一个强大的面向对象脚本语言（本文所用 Ruby 版本为1.8.6），在 Ruby 中 Symbol 表示“名字”，比如字符串的名字，标识符的名字。&lt;/li&gt;
  &lt;li&gt;创建：创建一个 Symbol 对象的方法是在名字或者字符串前面加上冒号：
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt; :foo
  =&amp;gt; :foo
  irb(main):002:0&amp;gt; :test
  =&amp;gt; :test
  irb(main):004:0&amp;gt; :&quot;foo is string&quot;
  =&amp;gt; :&quot;foo is string&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;h3 id=&quot;string&quot;&gt;String&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;定义：Ruby 中的 String 对象用于存储或操作一个或多个字节的序列。&lt;/li&gt;
  &lt;li&gt;创建：Ruby 字符串分为单引号字符串（’）和双引号字符串（”），区别在于双引号字符串能够支持更多的转义字符。
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):007:0&amp;gt; &quot;这是一个字符串&quot;
  =&amp;gt; &quot;这是一个字符串&quot;
  irb(main):008:0&amp;gt; '这也是一个字符串'
  =&amp;gt; &quot;这也是一个字符串&quot;

&lt;/code&gt;&lt;/pre&gt;
    &lt;h3 id=&quot;区别&quot;&gt;区别&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;因为在 Ruby 中字符串也是一种对象，即 String 对象。无论其结构还是操作和 Symbol 对象都是不同的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Ruby 中每一个对象都有唯一的对象标识符（Object Identifier）,可以通过 object_id 方法来得到一个对象的标识符&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Symbol&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):009:0&amp;gt; :foo.object_id
  =&amp;gt; 1149148
  irb(main):010:0&amp;gt; :foo.object_id
  =&amp;gt; 1149148
  irb(main):011:0&amp;gt; :&quot;foo&quot;.object_id
  =&amp;gt; 1149148

&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;String&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):014:0* &quot;foo&quot;.object_id
  =&amp;gt; 47353958516800
  irb(main):015:0&amp;gt; &quot;foo&quot;.object_id
  =&amp;gt; 47353958510640
  irb(main):016:0&amp;gt; &quot;foo&quot;.object_id
  =&amp;gt; 47353958500960

&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;从上面可以看出，　前三句都是同一个Symble对象，后三个都是不同的String对象&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;可见，每个 String 对象都是不同的，即便他们包含了相同的字符串内容；而对于 Symbol 对象，一个名字（字符串内容）&lt;strong&gt;唯一确定&lt;/strong&gt; 一个 Symbol 对象。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;em&gt;值得注意的是创建 Symbol 对象的字符串中不能含有’\0’字符，而 String 对象是可以的。&lt;/em&gt;
        &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt;  :&quot;fo\0o&quot;
  SyntaxError: compile error
  (irb):1: symbol cannot contain '\0'
       from (irb):1
  irb(main):002:0&amp;gt; :&quot;foo\0&quot;
  SyntaxError: compile error
  (irb):2: symbol cannot contain '\0'
       from (irb):2
  irb(main):003:0&amp;gt; puts &quot;foo\0&quot;.object_id
  24305140
  =&amp;gt; nil
  irb(main):004:0&amp;gt; puts &quot;fo\0o&quot;.object_id
  24301000
  =&amp;gt; nil
  irb(main):005:0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;经过实际测试发现并不是这样(可能是因为ruby版本不一致，测试版本为 2.3.1)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt; irb(main):002:0&amp;gt; :&quot;fo\0o&quot;
 =&amp;gt; :&quot;fo\x00o&quot;
 irb(main):003:0&amp;gt; :&quot;foo\0&quot;
 =&amp;gt; :&quot;foo\x00&quot;
 irb(main):004:0&amp;gt; puts &quot;foo\0&quot;.object_id
 47315761608520
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;除了可以采用一般的字符串，还可以使用操作符（例如+, -, *, /），变量，常量，方法甚至类的名字来创建 Symbol 对象，例如:+就是一个合法的 Symbol 。实际上，在 Ruby 内部操作符、变量等名字本身就是作为 Symbol 处理的，例如当你定义一个实例变量时， Ruby 会自动创建一个 Symbol 对象，例如 @test 对应为 :@test 。
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  # 实例变量的 Symbol

  class Test
   attr_accessor :test
  end
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个类定义了一个具有读写方法的实例变量 @test 。实际上 Ruby 创建了两个 Symbol ，一个是实例变量的 symbol :@test ，另一个是 :test 。那如果使用字符串对象 ”test” 作为参数呢？也可以，仍然会创建两个 symbol ，:test 和 :@test ，为什么还会创建 :test 呢？这是和Ruby的实现相关的（至少Ruby1.8.6里是这样）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意，&lt;strong&gt;类变量 @@test 和实例变量 @test 对应的 Symbol 显然是不同的。记住：名字相同，则Symbol 相同&lt;/strong&gt;。 名字相同， Symbol 相同&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  class Test
    puts :Test.object_id
    Test = 10
    puts :Test.object_id

    def Test
      puts :Test.object_id
    end
  end

  Test.new.Test
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;运行结果&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  224298
  224298
  224298
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;名字不同， Symbol 不同
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  class Test
    puts :Test.object_id

    @@test = 10
    puts :@@test.object_id
    def test
      puts :test.object_id
      @test = 10
      puts :@test.object_id

    end
  end

  t =Test.new
  t.test
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;运行结果&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;224298
288068
79858
288108
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Symbol 表示一个名字，仅此而已&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Symbol 对象一旦定义将一直存在，直到程序执行退出&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;可以通过类方法 Symbol.all_symbols 得到当前 Ruby 程序中定义的所有 Symbol 对象，该方法返回一个 Symbol 对象数组&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;string-和symbol&quot;&gt;String 和　Symbol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;String 类有很多方法，Symbol类只有all_symbols()的类方法和７个实例方法&lt;/li&gt;
  &lt;li&gt;虽然 Symbol 和 String 是不同的对象，但它们之间关系很密切。 Ruby 提供了方法在 Symbol和 String 之间转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;symbol-转化为-string&quot;&gt;Symbol 转化为 String&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Symbol 到 String
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt; :test.id2name
  =&amp;gt; &quot;test&quot;
  irb(main):002:0&amp;gt; :test.to_s
  =&amp;gt; &quot;test&quot;
  irb(main):003:0&amp;gt; :&quot;I am a boy&quot;.to_s
  =&amp;gt; &quot;I am a boy&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意，每个 String 对象都是唯一的，因此对一个 Symbol 调用多次将产生多个 String 对象。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;string-转化为-symbol&quot;&gt;String 转化为 Symbol&lt;/h4&gt;
&lt;p&gt;如果该 Symbol 已经存在，则直接返回。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;String 到 Symbol
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;irb(main):001:0&amp;gt; var1 = &quot;test&quot;.to_sym
=&amp;gt; :test
irb(main):002:0&amp;gt; var2 = &quot;test&quot;.intern
=&amp;gt; :test
irb(main):003:0&amp;gt; var1 == var2
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用-symbol&quot;&gt;使用 Symbol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Symbol本质上是 Ruby 符号表中的东西, 使用Symbol可以降低ruby内存消耗，提高执行速度&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通常来讲，当你面临 String 还是 Symbol 的选择时，可以参考以下标准：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;如果使用字符串的内容，这个内容可能会变化，使用 String&lt;/li&gt;
        &lt;li&gt;如果使用固定的名字或者说是标识符，使用 Symbol,比如枚举值、关键字（哈希表关键字、方法的参数）
          &lt;h4 id=&quot;hash中使用&quot;&gt;Hash中使用&lt;/h4&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 Symbol 作为 key
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  hosts = {
      :beijing =&amp;gt; 'machine1',
      :shanghai =&amp;gt; 'machine2',
      :guangzhou =&amp;gt; 'machine3',
      :tianjin' =&amp;gt; 'machine4',
      :shenzhen =&amp;gt; 'machine5'
      }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;使用　String 作为 key
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;   hosts = {
      &quot;beijing&quot; =&amp;gt; 'machine1',
      &quot;shanghai&quot; =&amp;gt; 'machine2',
      :guangzhou&quot; =&amp;gt; 'machine3',
      &quot;tianjin&quot; =&amp;gt; 'machine4',
      &quot;shenzhen&quot; =&amp;gt; 'machine5'
      }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每次获取hosts值的时候使用hosts[:beijing],不会创建新的对象。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每次获取hosts值的时候使用hosts[“beijing”],每次都会创建新的String对象，造成多余的内存和性能开销&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;哈希参数&quot;&gt;哈希参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;通常我们定义的函数的参数的个数和顺序是写死的，调用函数的时候要确保参数的个数、顺序匹配，有时候这样很不方便，使用哈希参数可以解决这个问题。&lt;/li&gt;
  &lt;li&gt;ROR 中就大量地运用这种方式，也许你已经看到了，到处都是 Symbol 和哈希&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用哈希参数的方法调用
    &lt;code&gt;ruby
    link_to 'Show', :action =&amp;gt; 'show', :id =&amp;gt; product
    add_column :products, :price, :decimal, :precision =&amp;gt; 8, :scale =&amp;gt; 2, :default =&amp;gt; 0
   &lt;/code&gt;&lt;/p&gt;
</description>
                <link>http://canmel.github.io/2017/07/13/ruby%E4%B8%ADString%E5%92%8Csymbol%E7%9A%84%E5%8C%BA%E5%88%AB</link>
                <guid>http://canmel.github.io/2017/07/13/ruby中String和symbol的区别</guid>
                <pubDate>2017-07-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>面试准备问题</title>
                <description>&lt;h5 id=&quot;高并发&quot;&gt;高并发&lt;/h5&gt;

&lt;h6 id=&quot;问题&quot;&gt;问题&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是原子操作&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是Executors框架？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。BlockingQueue 接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;高并发优化&quot;&gt;&lt;strong&gt;高并发优化&lt;/strong&gt;&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;从最基础的地方做起，优化我们写的代码，减少必要的资源浪费&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;避免频繁的使用new对象，对于整个应用只需要存在一个实例的类，我们可以使用单例模式。对于String连接操作，使用&lt;code&gt;StringBuffer&lt;/code&gt;或`StringBuilder，对于工具类可以通过静态方法来访问&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;避免使用错误的方式，尽量不用instanceof做条件判断。使用java中效率高的类，比如ArrayList比Vector性能&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;html静态化&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;我们通过一个链接地址访问，通过这个链接地址，服务器对应的模块处理这个请求，转到对应的jsp页面，最后生成我们要的数据。但是，如果上千万个请求的话，有太多的高并发请求，那么就会加重服务器的压力，最坏的情况是把服务器down掉。那么如何避免这种情况的出现呢？如果我们把最初对test.do的请求结果保存成一个html文件，然后每次用户都去访问这个html文件，这样就不用再去访问服务器了，服务器的压力不就减少了？ 当用户去访问，会自动的生成test.html ，然后再显示给用户&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片服务器分离&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对于web服务器来说，图片是最消耗资源的，于是我们有必要把图片与页面进行分离，我们把图片放到独立的图片        服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片的问题而崩                       溃。在图片服务器上，我们可以对不同的配置进行优&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓存
    &lt;ul&gt;
      &lt;li&gt;具体接触过的缓存机制是hibernate的缓存机制。为了避免每次都向数据库中取得数据，我们把用户常常访问到的数据放到内存中，甚至缓存十分大的时候我们可以把内存中的缓存放到硬盘中。还有高级的分布式缓存数据库使用，都可以增加系统的抗压力&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分批传送&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在做某项目的时候，一次传递的参数太多，而且数据库规定一次最多传递的参数最多是三万条，当时有五万条记录，那怎么传送呢？最终是分批传送，电梯里一次乘不下那么多的人，会报超重的bug，那就分批把人送上去,还有一次在考试系统中，如果那么多的考试人员同时提交到数据库中，数据库的压力增大，有时会被down掉，当时采用的方法是使用ajax异步传输，没有等待考生点击提交按钮的时候，就把考生的答案自动提交，这样也避免了突然断电考生前面做过的题出现丢失的现象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库集群&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当面对复杂的应用，用户大量访问的时候，一台数据很快无法满足需求，于是我们需要使用数据库集群或者库表散列。我们在应用程序中安装业务和应用或者功能模块将数据进行分离，不同的模块对应不同的数据库或表，再按照一定的策略对某个页面或者功能进行更小的数据库散列&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DB优化&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在数据库设计的时候就要考虑到后期的维护，数据库三范式是我们设计数据库索要遵循的原则&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
 &amp;gt; 数据库三范式

 &amp;gt; 第一范式：强调的是列的原子性

 &amp;gt; 第二范式： 首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分

 &amp;gt; 第三范式： 首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;索引的建立：建立索引要适当，如果一个表经常用来被查询，对于增加和修改很少被用到，我们就可以为这个表建立索引，因为对于增加和修改和删除操作时，我们对索引的维护要大大超过索引给我们带来的效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据库建立索引的优缺点&lt;/p&gt;

&lt;p&gt;优点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; * 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

 &amp;gt; * 可以大大加快数据的检索速度，这也是创建索引的最主要的原因

 &amp;gt; * 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义

 &amp;gt; * 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间- 表字段的类型选择要恰当

 &amp;gt; * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; * 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

 &amp;gt; * 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大
 &amp;gt; * 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
 &amp;gt; **适合建立索引的列 **
 &amp;gt; * 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
 &amp;gt; * 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
 &amp;gt; * 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
 &amp;gt; * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
 &amp;gt; * 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度
 &amp;gt; **不适合建立索引的列 **
 &amp;gt; * 对于那些在查询中很少使用或者参考的列不应该创建索引
 &amp;gt; * 对于那些只有很少数据值的列也不应该增加索引
 &amp;gt; * 对于那些定义为text, image和bit数据类型的列不应该增加索引

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;外键要慎用，因为主键代表这一张表，而外键代表一群表，对表之间进行了关联，在删除修改等需要我们关联&lt;/li&gt;
  &lt;li&gt;在数据库操作上尽量使用prepareStatement，少用Statement，因为&lt;strong&gt;PrepareStatement&lt;/strong&gt;是进行预编译的。connection设置为readOnly，Connection是对书库连接，属于重量级，我们使用即可。连接池的使用，我们可以修改数据库默认的连接数&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;多线程&quot;&gt;多线程&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;进程和线程之间有什么不同&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们如何创建一个线程？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有哪些不同的线程生命周期&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;new&lt;/code&gt;: 新建&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;runnable**&lt;/code&gt;: 调用start()&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;running&lt;/code&gt;: 线程理想状态，cpu分配了时间给了线程&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;blocked&lt;/code&gt;: 阻塞：sleep(), wait() –&amp;gt; 阻塞　–&amp;gt; notify(), notifyAll() –&amp;gt; runnable&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;dead&lt;/code&gt;: 死亡&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何确保main()方法所在的线程是Java程序最后结束的线程&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程之间是如何通信的&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\notify()\notifyAll()方法可以用于线程间通信关于资源的锁的状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么Thread类的sleep()和yield()方法是静态的？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;volatile关键字在Java中有什么作用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是ThreadLocal&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是死锁(Deadlock)？如何分析和避免死锁&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是线程池？如何创建一个Java线程池？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;锁&quot;&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/h5&gt;

&lt;h6 id=&quot;在多线程下一个非常重要的问题就是同步关于同步一般会有以下解决方法&quot;&gt;在多线程下，一个非常重要的问题就是同步,关于同步，一般会有以下解决方法&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在需要同步的方法的方法签名中加入synchronized关键字。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用synchronized块对需要进行同步的代码段进行同步&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;java内置锁&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;设计模式&quot;&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/h5&gt;

&lt;h6 id=&quot;列举几个常用的设计模式&quot;&gt;列举几个常用的设计模式&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;单例模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;单例模式有以下特点：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt; &amp;gt; 单例类只能有一个实例。
 &amp;gt; 单例类必须自己创建自己的唯一实例。
 &amp;gt; 单例类必须给所有其他对象提供这一实例。

&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;单利模式类型&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt; &amp;gt; 懒汉模式：　第一次调用的时候初始化实例（线程不安全，需要加同步）

 &amp;gt; 饿汉模式：　项目加载的时候初始化实例，　自始至终只有一个实例（天生线程安全）

&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工厂模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;工厂模式的两种情况&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;     &amp;gt; 在编码时不能预见需要创建哪种类的实例

     &amp;gt; 系统不应依赖于产品类实例如何被创建、组合和表达的细节
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代理模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;静态代理　&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; &amp;gt; 聚合实现方式中代理类聚合了被代理类，且代理类及被代理类都实现了同一个接口，可实现灵活多变。继承式的实现方式则不够灵活
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;动态代理&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; &amp;gt; 一般来说，对代理模式而言，一个主题类与一个代理类一一对应，这也是静态代理模式的特点。
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，也存在这样的情况，有n各主题类，但是代理类中的“前处理、后处理”都是一样的，仅调用主题不同。也就是说，多个主题类对应一个代理类，共享“前处理，后处理”功能，动态调用所需主题，大大减小了程序规模，这就是动态代理模式的特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JDK动态代理步骤&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &amp;gt; 创建一个实现InvocationHandler接口的类，它必须实现invoke()方法

  &amp;gt; 创建被代理的类及接口

  &amp;gt; 调用Proxy的静态方法，创建一个代理类

  &amp;gt; 通过代理调用方法
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;框架&quot;&gt;框架&lt;/h5&gt;

&lt;h6 id=&quot;mybatis&quot;&gt;Mybatis&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;实现原理&lt;/p&gt;

    &lt;p&gt;MyBatis应用程序根据&lt;code&gt;XML&lt;/code&gt;配置文件创建&lt;code&gt;SqlSessionFactory&lt;/code&gt;，&lt;code&gt;SqlSessionFactory&lt;/code&gt;在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个&lt;code&gt;SqlSession&lt;/code&gt;。&lt;code&gt;SqlSession&lt;/code&gt;包含了执行sql所需要的所有方法，可以通过&lt;code&gt;SqlSession&lt;/code&gt;实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭&lt;code&gt;SqlSession&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;简单易学&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;灵活&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;解除sql与程序代码的耦合&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供映射标签，支持对象与数据库的orm字段关系映射(orm)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供对象关系映射标签，支持对象关系组建维护(orm)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供xml标签，支持编写动态sql&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;二级缓存机制不佳&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总结&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;专注sql本身，程序员需要自己写sql语句，sql的修改与优化比较方便。它是一个不完全的ORM框架，虽然程序员自己写sql，但它自身也可以实现映射&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;适用与中小型项目&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由&lt;code&gt;apache software foundation&lt;/code&gt; 迁移到了google code，并且改名为MyBatis 。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Object(DAO)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis编程步骤是什么样的&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;创建&lt;strong&gt;SqlSessionFactory&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过SqlSessionFactory创建&lt;strong&gt;SqlSession&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过&lt;strong&gt;sqlsession&lt;/strong&gt;执行数据库操作&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;调用session.commit()提交事务&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;调用session.close()关闭会话&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用MyBatis的mapper接口调用时有哪些要求&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper接口方法名和mapper.xml中定义的每个sql的id相同&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper.xml文件中的namespace即是mapper接口的类路径&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简单的说一下MyBatis的一级缓存和二级缓存&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。Mybatis内部存储缓存使用一个&lt;code&gt;HashMap&lt;/code&gt;，key为&lt;code&gt;hashCode+sqlId+Sql&lt;/code&gt;语句。value为从查询出来映射生成的java对象&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的&lt;code&gt;namespace&lt;/code&gt;，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨&lt;code&gt;SqlSession&lt;/code&gt;的。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;springmvc&quot;&gt;SpringMVC&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;工作流程&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;用户发送请求至前端控制器DispatcherServlet&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet收到请求调用HandlerMapping处理器映射器&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;调用&lt;code&gt;HandlerAdapter&lt;/code&gt;处理器适配器&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HandlerAdapter经过适配调用具体的&lt;code&gt;处理器&lt;/code&gt;(Controller，也叫后端控制器)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Controller执行完成返回&lt;code&gt;ModelAndView&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet将ModelAndView传给&lt;code&gt;ViewReslover&lt;/code&gt;视图解析器&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ViewReslover解析后返回具体&lt;code&gt;View&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet响应用户&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下：&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;文件上传解析，如果请求类型是multipart将通过&lt;code&gt;MultipartResolver&lt;/code&gt;进行文件上传解析；&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;通过&lt;code&gt;HandlerMapping&lt;/code&gt;，将请求映射到&lt;code&gt;处理器&lt;/code&gt;（返回一个&lt;code&gt;HandlerExecutionChain&lt;/code&gt;，它包括一个处理器、多个HandlerInterceptor拦截器）&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;通过&lt;code&gt;HandlerAdapter&lt;/code&gt;支持多种类型的处理器(HandlerExecutionChain中的处理器)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;通过&lt;code&gt;ViewResolver&lt;/code&gt;解析逻辑视图名到具体视图实现；&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;本地化解析&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;渲染具体的视图等&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://canmel.github.io/2017/05/06/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87</link>
                <guid>http://canmel.github.io/2017/05/06/面试准备</guid>
                <pubDate>2017-05-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Rails中Excel的数据导入</title>
                <description>&lt;h4 id=&quot;rails中excel的数据导入&quot;&gt;Rails中Excel的数据导入&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从界面开始
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;首先创建一个表单&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code&gt;&amp;lt;%= bootstrap_form_tag url: '/imports' , :html =&amp;gt; {:id =&amp;gt; 'import_car_form', :multipart =&amp;gt; true} do |f| %&amp;gt;
    &amp;lt;input type=&quot;text&quot; size=&quot;50&quot; id=&quot;upfile&quot; name=&quot;upfile&quot; readonly&amp;gt;
    &amp;lt;%= f.file_field :file, class: &quot;hidden&quot;, hide_label: true, :onchange =&amp;gt; &quot;upfile.value=this.value&quot;, :required =&amp;gt; 'true'%&amp;gt;
    &amp;lt;a href=&quot;javascript:_file.click();&quot; class=&quot;btn btn-sm btn-success&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-plus&quot;&amp;gt;选择文件&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;%= f.submit &quot;上传&quot;, class: &quot;btn btn-sm btn-primary&quot; %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gemfile
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; gem 'roo ~&amp;gt;2.7.1'
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; bundle install
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;routes&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; resouces: imports
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;controller
    &lt;ul&gt;
      &lt;li&gt;controller中建立一个create方法&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在参数中获取临时文件，参数 &lt;code&gt;file&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  # rails默认的路由之一
  # 请求方式post
  def create
      tempfile = params[:file]
      require 'util/excel_util'
      if ExcelUtil.file_present? tempfile
          format = {name: &quot;名称&quot;, age: &quot;年龄&quot;, phone: &quot;手机&quot;}
          results = ExcelUtil.analysis upload_file, format
          # 在这里就获取到了结果集
          # 可以对数据进行持久化操作等
          # 但是得注意多数据操作的事务添加
      end
  end
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ExcelUtil&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  class ExcelUtil
      # 针对单行表头的excel表导入
      # 默认是使用excel的第二行开始计算有效数据，第一行为表头信息
      # upfile: 上传的临时文件
      # format: 定义的表头信息
      #   格式为： {property1: &quot;msg1&quot;, property2: &quot;msg2&quot;}
      # 	eg: format = {name: &quot;名称, price: &quot;价格&quot;, num: &quot;数量&quot;}
      # 返回值： json数组
      #   格式为： [{name: &quot;土豆&quot;， price: &quot;3&quot;, num: &quot;4&quot;}，{name: &quot;里脊肉&quot;， price: &quot;12&quot;, num: &quot;1&quot;}]
      # ==========================================================
      # 调用之前请先确认文件存在与正确性可调用 file_present? == true
      def analysis upfile, format
         require 'roo'
           xlsx = Roo::Spreadsheet.open(file, extension: :xlsx)
           result = []
           xlsx.each_with_pagename do |name, sheet|
            sheet.each do |hash, index|
               result &amp;lt;&amp;lt; hash if index != 0
     		  end
         end
         result
      end
      # 判断文件是否存在或者符合要求
      # 必须是以xlsx或xls结尾的文件
      def file_present? file
        return false if file.nil?
        if file.instance_of? ActionDispatch::Http::UploadedFile
          original_name = file.original_filename
        else
          original_name = file.path
        end
        suffix = original_name.split('.').last
        return suffix === &quot;xls&quot; || suffix === &quot;xlsx&quot; ? true : false
      end
      # TODO 比较复杂的excel的导入（多行表头）
  end
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://canmel.github.io/2017/04/11/Rails%E4%B8%ADExcel%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5</link>
                <guid>http://canmel.github.io/2017/04/11/Rails中Excel的数据导入</guid>
                <pubDate>2017-04-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Mybatis实践</title>
                <description>&lt;h3 id=&quot;mybatis实践&quot;&gt;Mybatis实践&lt;/h3&gt;

&lt;h4 id=&quot;mybatis简介&quot;&gt;MyBatis简介&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* Mybatis前身是iBatis,是一个基于java的数据持久层/(半)对相关系映射框架

* Mybatis是对jdbc的封装，是开发人员只需要关注SQL本身，而不需要话费过多的精力去处理如注册驱动，设置参数，创建connection / Statement , 解析结果集等JDBC过程性代码，Bybatis基于XML/注解的方式配置statement，执行SQL，并将执行结果映射成JAVA对象，大大降低了数据库开发难度
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;初识&quot;&gt;初识&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* 使用Mybatis,需要在pom.xml添加依赖,顺手加上mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.26&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* MyBatis的配置分为两类

    * 一类将Mybatis配置进项目中使用，`mybatis-config.xml`,网上关于这类配置很多,一半结合springMVC,会使用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;spring-mybatis.xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
        &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context-3.1.xsd
                                http://www.springframework.org/schema/mvc
                                http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&amp;gt;
        	&amp;lt;!-- 自动扫描 --&amp;gt;
        	&amp;lt;context:component-scan base-package=&quot;com.meedesidy&quot; /&amp;gt;
        	&amp;lt;!-- 引入配置文件 --&amp;gt;
        	&amp;lt;bean id=&quot;propertyConfigurer&quot;
        		class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&amp;gt;
        		&amp;lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&amp;gt;
        	&amp;lt;/bean&amp;gt;
        	&amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        		destroy-method=&quot;close&quot;&amp;gt;
        		&amp;lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&amp;gt;
        		&amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&amp;gt;
        		&amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&amp;gt;
        		&amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&amp;gt;
        		&amp;lt;!-- 初始化连接大小 --&amp;gt;
        		&amp;lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 连接池最大数量 --&amp;gt;
        		&amp;lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 连接池最大空闲 --&amp;gt;
        		&amp;lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 连接池最小空闲 --&amp;gt;
        		&amp;lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 获取连接最大等待时间 --&amp;gt;
        		&amp;lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        	&amp;lt;/bean&amp;gt;
        	&amp;lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&amp;gt;
        	&amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
        		&amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
        		&amp;lt;property name=&quot;plugins&quot;&amp;gt;
        			&amp;lt;list&amp;gt;
        				&amp;lt;bean class=&quot;com.meedesidy.plugin.PagePlugin&quot;&amp;gt;
        					&amp;lt;property name=&quot;pageSqlId&quot; value=&quot;.*pageQuery.*&quot; /&amp;gt;
        					&amp;lt;property name=&quot;dialect&quot; value=&quot;postgres&quot; /&amp;gt;
        				&amp;lt;/bean&amp;gt;
        			&amp;lt;/list&amp;gt;
        		&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 自动扫描mapping.xml文件 --&amp;gt;
        		&amp;lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/meedesidy/mapping/*.xml&quot;&amp;gt;&amp;lt;/property&amp;gt;
      &amp;lt;/bean&amp;gt;
        &amp;lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&amp;gt;
       &amp;lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&amp;gt;
            &amp;lt;property name=&quot;basePackage&quot; value=&quot;com.meedesidy.dao&quot; /&amp;gt;
            &amp;lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
        &amp;lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&amp;gt;
        	&amp;lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        		    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
        	&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    * 另一类配置文件是数据访问接口配置文件，如　`UserMapper.xml`
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;test.mybatis.UserDao&quot;&amp;gt;
    &amp;lt;!-- 这里namespace必须是UserMapper接口的路径” --&amp;gt;
    &amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&amp;gt;
        insert into user(name,age) values(#{name},#{age})
        &amp;lt;!-- 这里sql结尾不能加分号，否则报“ORA-00911”的错误 --&amp;gt;
    &amp;lt;/insert&amp;gt;

    &amp;lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同 --&amp;gt;
    &amp;lt;select id=&quot;getUser&quot; resultType=&quot;User&quot; parameterType=&quot;java.lang.String&quot;&amp;gt;
        select * from user where name=#{name}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;mybatis 需要定义Dao接口，mapper中定义的id与接口中的方法名相同&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mybatis通过JDK的动态代理方式，在启动加载配置文件时，根据配置mapper的xml去生成Dao的实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在mybatis 配置文件中加入扫描，在启动时加载mapper文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;又通过namespace的映射，映射到要实现的接口，代理类通过&lt;code&gt;接口- MapperID&lt;/code&gt;找到相应的MappedStatement&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jdbc配置&quot;&gt;jdbc配置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用配置文件　&lt;code&gt;jdbc.propertis&lt;/code&gt;保存jdbc链接信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JDBC编程的步骤&lt;/strong&gt;：
– 加载数据库驱动
– 创建并获取数据库链接
– 创建jdbc statement对象
– 设置sql语句
– 设置sql语句中的参数(使用preparedStatement)
– 通过statement执行sql并获取结果
– 对sql执行结果进行解析处理
– 释放资源(resultSet、preparedstatement、connection)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MyBatis执行过程&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;– 通过mybatis环境等配置信息构造&lt;strong&gt;SqlSessionFactory&lt;/strong&gt;即会话工厂&lt;/p&gt;

&lt;p&gt;– 由会话工厂创建&lt;strong&gt;sqlSession&lt;/strong&gt;即会话，操作数据库需要通过&lt;strong&gt;sqlSession&lt;/strong&gt;进行。&lt;/p&gt;

&lt;p&gt;– mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行&lt;/p&gt;

&lt;p&gt;– Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对        应一个Mapped Statement对象，sql的id即是Mapped statement的id。&lt;/p&gt;

&lt;p&gt;– Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前               将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。
&lt;img src=&quot;http://olvg7xziu.bkt.clouddn.com/20160725221506672.jpg&quot; alt=&quot;mybatis&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;连接池&quot;&gt;连接池&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;mybatis 把数据源分为三种：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UNPOOLED    不使用连接池的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;POOLED        使用连接池的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JNDI                 使用JNDI实现的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相应地，MyBatis内部分别定义了实现了&lt;strong&gt;Java.sql.DataSource&lt;/strong&gt;接口的&lt;strong&gt;UnpooledDataSource&lt;/strong&gt;，&lt;strong&gt;PooledDataSource&lt;/strong&gt;类来表示&lt;code&gt;UNPOOLED&lt;/code&gt;、&lt;code&gt;POOLED&lt;/code&gt;类型的数据源&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;重复创建javasqlconnection去链接数据库对cpu的开销是不必要的负担连接池解决这个矛盾&quot;&gt;重复创建&lt;code&gt;java.sql.Connection&lt;/code&gt;去链接数据库对cpu的开销是不必要的负担，连接池解决这个矛盾&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;对于需要频繁地跟数据库交互的应用程序，可以在创建了&lt;strong&gt;Connection对象&lt;/strong&gt;，并操作完数据库后，可以不释放掉资源，而是将它放到&lt;strong&gt;内存&lt;/strong&gt;中，当下次需要操作数据库时，可以直接从内存中取出Connection对象，不需要再创建了，这样就极大地节省了创建Connection对象的资源消耗。由于内存也是有限和宝贵的，这又对我们对内存中的Connection对象怎么有效地维护提出了很高的要求。我们将在内存中存放Connection对象的容器称之为 连接池（Connection Pool）&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://canmel.github.io/2017/04/11/Mybatis(%E5%88%9D%E8%AF%86)</link>
                <guid>http://canmel.github.io/2017/04/11/Mybatis(初识)</guid>
                <pubDate>2017-04-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用angularJs （二）</title>
                <description>&lt;h4 id=&quot;使用angularjs-二&quot;&gt;使用angularJs （二）&lt;/h4&gt;
&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;后台支持： Java , springMVC, mybatis, mysql&lt;/li&gt;
  &lt;li&gt;前端框架： Jquery , BootStrap , AngularJs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一般AngularJs 应用在一个单页面的web项目中，一般结构为
    &lt;ul&gt;
      &lt;li&gt;head
        &lt;ul&gt;
          &lt;li&gt;js和css文件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;body
        &lt;ul&gt;
          &lt;li&gt;header&lt;/li&gt;
          &lt;li&gt;sidebar(菜单部分)&lt;/li&gt;
          &lt;li&gt;main-content&lt;/li&gt;
          &lt;li&gt;footer&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一般header和footer都是固定的,点击菜单（sidebar）中的菜单，页面（main-content）部分做出相应的改变，本文仅围绕这个模式书写&lt;/li&gt;
  &lt;li&gt;在&lt;code&gt;main-content&lt;/code&gt;上设置属性&lt;code&gt;ui-view&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;ui-view&lt;/code&gt;是告诉angularJs,今后更改页面，刷新页面，就在这个属性所在的标签下，在你还没有告诉angular要去哪个页面的时候，angular会去路由中找到默认路由去渲染&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;左侧菜单设置设置相应的&lt;code&gt;controller&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;新建&lt;code&gt;sidebarController.js&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;建立go方法
        &lt;ul&gt;
          &lt;li&gt;
            &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;   meedesidy.controller('sidebar', [ '$scope', '$http', '$state', '$stateParams', function($scope, $http, $state, stateParams) {
       //调用go方法跳往指定页面，在ui-view下显示
       $scope.go = function($event, url) {
           $state.go(url);
       }
   }]);

&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在菜单中设置ng-click点击事件
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;a ng-click=&quot;go($event, '/users')&quot;&amp;gt;用户菜单&amp;lt;/a&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;这样在页面中点击了&lt;code&gt;用户菜单&lt;/code&gt;在&lt;code&gt;ui-view&lt;/code&gt;中就可以看到路由中定义的templateUrl，即&lt;code&gt;pages/user/index.jsp&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;相应的设置其他路由，即可显示其他界面&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;angularJs中的子路由
    &lt;ul&gt;
      &lt;li&gt;点击每一个菜单会相应的改变&lt;code&gt;ui-view&lt;/code&gt;中的jsp,在jsp中会有属于各页面的路由，如：user.jsp中会有&lt;code&gt;新建用户&lt;/code&gt;的链接，这就需要一个新的子路由，下面开始创建子路由&lt;/li&gt;
      &lt;li&gt;子路由的创建也很简单，之前配置路由的时候会在每个路由下设置一个&lt;code&gt;controller&lt;/code&gt;的属性.&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  .state('user', {
      url: '/user',
      templateUrl: 'pages/user/index.jsp',
      controller: 'user'
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;该属性表明：在当前路由下的页面（现在就是jsp）,使用另外一个controller,这个controller的名字就叫user&lt;/li&gt;
      &lt;li&gt;每一次在&lt;code&gt;xxxController.js&lt;/code&gt;中设置controller的时候，都会设置它的名字，第一个参数就是&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  meedesidy.controller('user', ['$scope', '$http', '$state', '$stateParams', function($scope, $http, $state, $stateParams) {
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;这样在就将页面和新建的controller连在一起了，可以在controller中操作页面中的内容&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;在&lt;code&gt;userController.js&lt;/code&gt;中创建子路由&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  meedesidy.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) {
  //	配置基本路由
      $stateProvider.state('newUser',{
          url: '/user/new',
          templateUrl: 'pages/user/new.jsp',
          controller: 'user'
      }).state('editUser',{
          url: '/user/edit/{id}',
          templateUrl: 'pages/user/new.jsp',
          controller: 'user'
      });
  }]);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;这样在user.jsp中就多了几个子路由：&lt;code&gt;newUser&lt;/code&gt;和&lt;code&gt;editUser&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;子路由的使用
    &lt;ul&gt;
      &lt;li&gt;子路由的使用和基本路由一样，不论是超链接还是使用go方法跳转，都一样使用&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你可以这样使用：&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;a ui-sref=&quot;newUser&quot;&amp;gt;新建用户&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;也可以这样用：&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code&gt;  &amp;lt;a ng-click=&quot;go(newUser)&quot;&amp;gt;新建&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;然后建立相应的go方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;到这里angularjs的基本使用就差不多了剩下的就是一些使用了但关键就是一个数据的双向绑定&quot;&gt;到这里angularJs的基本使用就差不多了，剩下的就是一些使用了，但关键就是一个数据的双向绑定&lt;/h3&gt;

</description>
                <link>http://canmel.github.io/2017/04/11/AngularJs%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%BA%8C</link>
                <guid>http://canmel.github.io/2017/04/11/AngularJs的使用（二）</guid>
                <pubDate>2017-04-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用angularJs （一）</title>
                <description>&lt;h4 id=&quot;使用angularjs-一&quot;&gt;使用angularJs （一）&lt;/h4&gt;

&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;后台支持： Java , springMVC, mybatis, mysql&lt;/li&gt;
  &lt;li&gt;前端框架： Jquery , BootStrap , AngularJs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;创建app.js
    &lt;ul&gt;
      &lt;li&gt;创建ng-app&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;在标签上添加&lt;code&gt;ng-app&lt;/code&gt;属性
        &lt;ul&gt;
          &lt;li&gt;如： &lt;code&gt;&amp;lt;body ng-app='meedesidy'&amp;gt;&amp;lt;/body&amp;gt;&lt;/code&gt;这样就创建了一个名称为&lt;code&gt;meedesidy&lt;/code&gt;的angular项目
            &lt;ul&gt;
              &lt;li&gt;设置路由&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code&gt;app.js&lt;/code&gt;中设置路由，一般都是在spa(single page application 单页面项目)中使用angularJs,这里配置的是在主页面下的子页面的路由&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;代码：&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  meedesidy.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) {

      //	默认路由
      $urlRouterProvider.otherwise('index');

      //	配置基本路由
      $stateProvider.state('index', {
          url: '/index',
          templateUrl: 'pages/index.jsp'
      }).state('user', {
          url: '/user',
          templateUrl: 'pages/user/index.jsp',
          controller: 'user'
      })；
  }]);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;当angular找不到指定的路由会去寻找指定的路由，这里设置的是 index&lt;/li&gt;
      &lt;li&gt;当访问&lt;code&gt;localhost:8080/project/#/user&lt;/code&gt;会去渲染加载&lt;code&gt;user/index.jsp&lt;/code&gt;这个模板,并且会设置当前的控制器名称为&lt;code&gt;menu&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;设置了控制器名称，必须要加载相应的控制器,才能在相应的控制器中控制user/index.jsp中的内容
    * 设置控制器&lt;/li&gt;
      &lt;li&gt;在javascript文件夹下创建controller文件夹，并在controller文件夹下创建&lt;code&gt;userController.js&lt;/code&gt;文件&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在controller文件中添加controller&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // 在app-name 下定义一个 name为 user 的controller
  meedesidy.controller('user', ['$scope', '$http', '$state', '$stateParams', function($scope, $http, $state, $stateParams) {


  }]);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP请求
    &lt;ul&gt;
      &lt;li&gt;http请求需要注入&lt;code&gt;$http&lt;/code&gt;服务&lt;/li&gt;
      &lt;li&gt;请求：&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-jacascript&quot;&gt;  $http({
      method: &quot;post&quot;,	// 发送一个post请求
      url: &quot;/xxx/user/pageQuery&quot;,
      data: $.param($scope.searchParams),	// 参数，可表达式
      headers : { 'Content-Type': 'application/x-www-form-urlencoded' } //header可选，头部信息
  }).then(function(resp){		//请求成功回调 参数是response
      $scope.datas = resp.data.result;
  }),(function(resp){			//请求失败的回调 参数是response
      console.info(resp);
  });


&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;请求获取到了数据现在就可以在界面上显示了&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://canmel.github.io/2017/04/11/AngularJs%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%80</link>
                <guid>http://canmel.github.io/2017/04/11/AngularJs的使用（一）</guid>
                <pubDate>2017-04-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mybatis 缓存</title>
                <description>&lt;h4 id=&quot;mybatis-缓存分为一级缓存和二级缓存&quot;&gt;mybatis 缓存分为一级缓存和二级缓存&lt;/h4&gt;

&lt;h5 id=&quot;一级缓存&quot;&gt;一级缓存&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;MyBatis的一级缓存指的是在一个Session域内,session为关闭的时候执行的查询会根据SQL为key被缓存(跟mysql缓存一样,修改任何参数的值都会导致缓存失效)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;– 单独使用MyBatis而不继承Spring,使用原生的MyBatis的SqlSessionFactory来构造sqlSession查询,是可以使用以及缓存的&lt;/p&gt;

&lt;p&gt;— 当参数不变的时候只进行了一次查询,参数变更以后,则需要重新进行查询,而清空缓存以后,参数相同的查询过的SQL也需要重新查询&lt;/p&gt;

&lt;p&gt;– 跟Spring集成的时候(使用mybatis-spring)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

@Repository
public class UserDao extends SqlSessionDaoSupport {
    public User selectUserById(int id) {
        SqlSession session = getSqlSession();
        session.selectOne(&quot;dao.userdao.selectUserByID&quot;, id);
        // 由于session的实现是SqlSessionTemplate的动态代理实现
        // 它已经在代理类内执行了session.close(),所以无需手动关闭session
        return session.selectOne(&quot;dao.userdao.selectUserByID&quot;, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里执行了2次sql查询,看似我们使用了同一个sqlSession,但是实际上因为我们的dao继承了SqlSessionDaoSupport,而SqlSessionDaoSupport内部sqlSession的实现是使用用动态代理实现的,这个动态代理sqlSessionProxy使用一个模板方法封装了select()等操作,每一次select()查询都会自动先执行openSession(),执行完close()以后调用close()方法,相当于生成了一个新的session实例,所以我们无需手动的去关闭这个session()(关于这一点见下面mybatis的官方文档),当然也无法使用mybatis的一级缓存,也就是说mybatis的一级缓存在spring中是没有作用的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;官方文档摘要&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;MyBatis SqlSession provides you with specific methods to handle transactions programmatically. But when using MyBatis-Spring your beans will be injected with a Spring managed SqlSession or a Spring managed mapper. That means that Spring will always handle your transactions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;You cannot call SqlSession.commit(), SqlSession.rollback() or SqlSession.close() over a Spring managed SqlSession. If you try to do so, a UnsupportedOperationException exception will be thrown. Note these methods are not exposed in injected mapper classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;二级缓存&quot;&gt;二级缓存&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;二级缓存就是global caching,它超出session范围之外,可以被所有sqlSession共享,它的实现机制和mysql的缓存一样,开启它只需要在mybatis的配置文件开启settings里的&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;

&amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;以及在相应的Mapper文件(例如userMapper.xml)里开启&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;

&amp;lt;mapper namespace=&quot;dao.userdao&quot;&amp;gt;
   ...  select statement ...
       &amp;lt;!-- Cache 配置 --&amp;gt;
    &amp;lt;cache
        eviction=&quot;FIFO&quot;
        flushInterval=&quot;60000&quot;
        size=&quot;512&quot;
        readOnly=&quot;true&quot; /&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;需要注意的是global caching的作用域是针对Mapper的Namespace而言的,也就是说只在有在这个Namespace内的查询才能共享这个cache.例如上面的 dao.userdao namespace, 下面是官方文档的介绍&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;It’s important to remember that a cache configuration and the cache instance are bound to the namespace of the SQL Map file. Thus, all statements in the same namespace as the cache are bound by it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;当我们访问两次 /getUser 这个url,查看日志输出&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;DEBUG - Creating a new SqlSession
DEBUG - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@659812] was not registered for synchronization because synchronization is not active
DEBUG - Cache Hit Ratio [dao.userdao]: 0.0
DEBUG - Fetching JDBC Connection from DataSource
DEBUG - JDBC Connection [jdbc:mysql://127.0.0.1:3306/mybatistest?characterEncoding=utf8, UserName=root@localhost, MySQL-AB JDBC Driver] will not be managed by Spring
DEBUG - ooo Using Connection [jdbc:mysql://127.0.0.1:3306/mybatistest?characterEncoding=utf8, UserName=root@localhost, MySQL-AB JDBC Driver]
DEBUG - ==&amp;gt; Preparing: SELECT * FROM user WHERE id = ?
DEBUG - ==&amp;gt; Parameters: 1(Integer)
DEBUG - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@659812]
DEBUG - Returning JDBC Connection to DataSource
DEBUG - Invoking afterPropertiesSet() on bean with name 'index'
DEBUG - Rendering view [org.springframework.web.servlet.view.JstlView: name 'index'; URL [/index.jsp]] in DispatcherServlet with name 'dispatcher'
DEBUG - Added model object 'org.springframework.validation.BindingResult.user' of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name 'index'
DEBUG - Added model object 'user' of type [bean.User] to request in view with name 'index'
DEBUG - Forwarding to resource [/index.jsp] in InternalResourceView 'index'
DEBUG - Successfully completed request
DEBUG - Returning cached instance of singleton bean 'sqlSessionFactory'
DEBUG - DispatcherServlet with name 'dispatcher' processing GET request for [/user/getUser]
DEBUG - Looking up handler method for path /user/getUser
DEBUG - Returning handler method [public java.lang.String controller.UserController.getUser(org.springframework.ui.Model)]
DEBUG - Returning cached instance of singleton bean 'userController'
DEBUG - Last-Modified value for [/user/getUser] is: -1
DEBUG - Creating a new SqlSession
DEBUG - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@539a92] was not registered for synchronization because synchronization is not active
DEBUG - Cache Hit Ratio [dao.userdao]: 0.5
DEBUG - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@539a92]
DEBUG - Rendering view [org.springframework.web.servlet.view.JstlView: name 'index'; URL [/index.jsp]] in DispatcherServlet with name 'dispatcher'
DEBUG - Added model object 'org.springframework.validation.BindingResult.user' of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name 'index'
DEBUG - Added model object 'user' of type [bean.User] to request in view with name 'index'
DEBUG - Forwarding to resource [/index.jsp] in InternalResourceView 'index'
DEBUG - Successfully completed request
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;可以看出第二次访问同一个url的时候相同的查询 hit cache了,这就是global cache的作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文来自&lt;a href=&quot;http://www.cnblogs.com/zemliu/archive/2013/08/05/3239014.html&quot;&gt;今天的风儿好喧嚣啊~ MyBatis 缓存&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://canmel.github.io/2016/05/21/Mybatis(%E7%BC%93%E5%AD%98)</link>
                <guid>http://canmel.github.io/2016/05/21/Mybatis(缓存)</guid>
                <pubDate>2016-05-21T05:11:27+08:00</pubDate>
        </item>

        <item>
                <title>高并发控制</title>
                <description>&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优化代码&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;避免使用&lt;code&gt;new&lt;/code&gt;对象，对整个应用尽量使用一个对象，可使用单利模式。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对&lt;code&gt;String&lt;/code&gt;链接操作，使用&lt;code&gt;StringBuffer&lt;/code&gt;或&lt;code&gt;StringBuildder&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;html静态化&quot;&gt;html静态化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;高并发下服务器转化&lt;code&gt;jsp&lt;/code&gt;为&lt;code&gt;html&lt;/code&gt;会加重服务器负担,有可能的话，使用静态&lt;code&gt;html&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;图片服务器分离&quot;&gt;图片服务器分离&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;图片等静态资源放在独立服务器上，让服务器专注数据的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;缓存&quot;&gt;缓存&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code&gt;hibernate&lt;/code&gt;的缓存机制，或使用缓存，如&lt;code&gt;redis&lt;/code&gt;，以缓解服务器压力&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分批传送&quot;&gt;分批传送&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;有时还传送数据过大，需将数据分批传送，防止一次大量数据传输，数据保存时失败，导致大量数据丢失&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据库集群&quot;&gt;数据库集群&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;面对大量的数据请求，一台服务器可能已经无法满足数据的交换，于是就需要数据库集群或数据表散列。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;db优化&quot;&gt;DB优化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;遵循数据库设计三范式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;适当建立索引&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;慎用外键&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://canmel.github.io/2016/05/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%8E%A7%E5%88%B6</link>
                <guid>http://canmel.github.io/2016/05/21/高并发的控制</guid>
                <pubDate>2016-05-21T05:11:27+08:00</pubDate>
        </item>

        <item>
                <title>rubymine激活</title>
                <description>&lt;pre&gt;&lt;code&gt;4UXNY6NKFS-eyJsaWNlbnNlSWQiOiI0VVhOWTZOS0ZTIiwibGljZW5zZWVOYW1lIjoiVXNlciBDb2RlciIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJGb3IgZWR1Y2F0aW9uYWwgdXNlIG9ubHkiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifSx7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifV0sImhhc2giOiI1Mjk5NjU1LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-vaN2LDXEHZhJuA6ty/l8gqzoAfnxXdgWVDw8boMp8HzNP9J573xXWOy9THOjEgl0350zGrLyU5Yfb3FLCBbKCIQaVyKES1Y32ykO7oAPg74zikYTCfP582HB0pzgvr7jsFFxgyCYvwU+UavEcCyOV0/iF3WJIuP5l013w6xcpcCVS9TvarpFFExKilKzyg1295t8Cki1Y6uJkW3ZcexPfED/iEkhdb5CMfYeuTZ2DvC/+b0Ec7N0gitBxIQsJwRZvVGXcd2GVG+Tersgygk0rZwGoVmdXh5k58Y3ZWkkKGfeBomZwrdx0ONo6GWtrL2sEIl0LKpjA5EKrxxHxsN6kA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==

&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://canmel.github.io/2016/05/21/rubymine%E6%BF%80%E6%B4%BB</link>
                <guid>http://canmel.github.io/2016/05/21/rubymine激活</guid>
                <pubDate>2016-05-21T05:11:27+08:00</pubDate>
        </item>

        <item>
                <title>Jekyll Introduction</title>
                <description>
&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we’ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&quot;what-is-jekyll&quot;&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as “a simple, blog aware, static site generator”.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;what-does-jekyll-do&quot;&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, 
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id=&quot;jekyll-is-not-blogging-software&quot;&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id=&quot;why-should-i-care&quot;&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
  &lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
  &lt;li&gt;No internet connection required.&lt;/li&gt;
  &lt;li&gt;Ability to publish via git.&lt;/li&gt;
  &lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
  &lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
  &lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-jekyll-works&quot;&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately 
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id=&quot;initial-setup&quot;&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you’ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id=&quot;the-jekyll-application-base-format&quot;&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;
  Stores configuration data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;
  This folder is for partial views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;
  This folder is for the main templates your content will be inserted into.
  You can have different layouts for different pages or page sections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;
  This folder contains your dynamic content/posts.
  the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;
  This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;
  This folder is not part of the standard jekyll structure.
  The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
  Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;jekyll-configuration&quot;&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;content-in-jekyll&quot;&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content “objects” get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id=&quot;posts-and-pages&quot;&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id=&quot;working-with-posts&quot;&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. 
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post’s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy “set”.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy “lessons/beginner”. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won’t find “lessons” and “beginner” as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id=&quot;working-with-pages&quot;&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;templates-in-jekyll&quot;&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page’s or post’s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
Templates should be coded in HTML and contain YAML Front Matter. 
All templates can contain Liquid code to work with your site’s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sub-templates&quot;&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they 
define another “root” layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id=&quot;includes&quot;&gt;Includes&lt;/h3&gt;
&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id=&quot;using-liquid-for-templating&quot;&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id=&quot;what-is-liquid&quot;&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files 
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data.&lt;/p&gt;

&lt;h3 id=&quot;why-do-we-have-to-use-liquid&quot;&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;. 
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id=&quot;liquid-is-not-programmer-friendly&quot;&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can’t do jackshit in liquid that hasn’t been allowed explicitly by the implementation.
What’s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll’s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. 
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to 
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;
My personal stance is to not invest time trying to hack liquid. It’s really unnecessary
&lt;em&gt;from a programmer’s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I’ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-assets&quot;&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-parses-files&quot;&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;
  This is done with textile or markdown.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;  &lt;br /&gt;
  These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
  Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through 
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id=&quot;formatting-files-for-parsing&quot;&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We’ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;defining-layouts-for-posts-and-templates-parsing&quot;&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you’d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-generates-the-final-static-files&quot;&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll’s job is to generate a static representation of your website. 
The following is an outline of how that’s done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one 
  big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
  At this stage your site is one big computed ruby object.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;
  Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
  Once the post is parsed and liquified inside the the proper layout structure, the layout itself is “liquified”. &lt;br /&gt;
 &lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
  hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;
 Finally the liquid templates are “rendered”, thereby processing any liquid syntax provided in the templates
 and saving the final, static representation of the file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to 
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you’ll iterate through and format 
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
  &lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you’d like.&lt;/p&gt;
</description>
                <link>http://canmel.github.io/lessons/2011/12/29/jekyll-introduction</link>
                <guid>http://canmel.github.io/lessons/2011/12/29/jekyll-introduction</guid>
                <pubDate>2011-12-29T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
