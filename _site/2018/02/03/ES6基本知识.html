
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>ES6基本知识</title>
    <meta name="description" content="">
    <meta name="author" content="Meedesidy">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="/assets/themes//resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link rel="shortcut icon"href="/factive.ico">
    <!--[if lt IE 9]>
      <script src="/assets/themes//resources/respond/Respond.min.js"></script>
    <![endif]-->

    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Meedesidy Blog</a>
        </div>

        <div class="collapse navbar-collapse navbar-ex1-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
      	
      	<li><a href="/archive">文档</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags">标签</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      
<div class="page-header">
  <h1>ES6基本知识 </h1>
</div>

<div class="row post-full">
  <div class="col-md-12">
    <div class="date">
      <span>03 February 2018</span>
    </div>
    <div class="content">
      <h3 id="定义">定义</h3>
<ul>
  <li>使用<code>let</code>定义变量，使用<code>const</code>定义常量；</li>
  <li>常量只能定义一次，第二次定义常量回报错；</li>
</ul>

<pre><code class="language-javascript">const a = 1;
a = 2;
// Error: 
// TypeError: Attempted to assign to readonly property.
</code></pre>

<ul>
  <li>不能2次定义</li>
</ul>

<pre><code class="language-javascript">let a = 1;
let a = 2;

// error:
// SyntaxError: Cannot declare a let variable twice: 'a'.
</code></pre>

<h3 id="模板字符串">模板字符串</h3>

<ul>
  <li>使用<code>` `</code></li>
</ul>

<pre><code class="language-javascript"> // es5
    var msg = "Hi \
    man!
    "
 // es6
const template = `&lt;div&gt;
        &lt;span&gt;hello world&lt;/span&gt;
    &lt;/div&gt;`
</code></pre>

<h3 id="字符串操作">字符串操作</h3>

<ul>
  <li>判断是否包含</li>
</ul>

<pre><code class="language-javascript">let test = "teststr";
console.info(test.includes("s")); //true
console.log(test.repeat(3)); // teststrteststrteststr
</code></pre>

<h3 id="字符串拼接">字符串拼接</h3>

<p>ES5：</p>

<pre><code class="language-javascript">var name = "namestr"
console.info("first" + name);
</code></pre>

<pre><code class="language-javascript">let test = "namestr";
console.info(`first${test}`);
</code></pre>

<h3 id="函数">函数</h3>

<ul>
  <li>默认值</li>
</ul>

<pre><code class="language-javascript">num = num || 200
// 当num没有值等于200,即默认值200
</code></pre>

<ul>
  <li>函数参数默认值</li>
</ul>

<pre><code class="language-javascript">function action(num = 200) {
//    console.log(num);
}

action(); //200
action(300); //300

</code></pre>
<ul>
  <li>箭头函数</li>
</ul>

<pre><code class="language-javascript">[1,2,3].map( x =&gt; x + 1 )
// map() 执行一段function，返回一个执行后的数组
// [2,3,4]
</code></pre>

<ul>
  <li>省略参数括号</li>
</ul>

<pre><code class="language-javascript">//有且仅有一个参数的时候，是可以省略掉括号的
var people = name =&gt; 'hello' + name

// 大于一个参数不能省略 
var people = (name, age) =&gt; {
    const fullName = 'h' + name
    return fullName
} 
</code></pre>

<h3 id="拓展的对象功能">拓展的对象功能</h3>

<ul>
  <li>对象初始化简写</li>
</ul>

<pre><code class="language-javascript">// ES5 
function people(name, age) {
    return {
        name: name,
        age: age
    };
}
// ES6
function people(name, age) {
    return {
        name,
        age
    };
}
</code></pre>

<ul>
  <li>对象字面量</li>
</ul>

<pre><code class="language-javascript">// ES5
var people = {
    name: 'lux',
    getName: function() {
        console.log(this.name)
    }
}

// ES6
// ES6通过省略冒号与 function 关键字，将这个语法变得更简洁
const people = {
        name: 'lux',
        getName () {
            console.log(this.name)
        }
    }

</code></pre>

<ul>
  <li>对象浅复制</li>
</ul>

<pre><code class="language-javascript">// Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象
// 第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}
const obj = Object.assign({}, objA, objB)
</code></pre>

<ul>
  <li>更方便的数据访问–解构</li>
</ul>

<pre><code class="language-javascript">// ES5
const people = {
    name: 'lux',
    age: 20
}
const name = people.name
const age = people.age
console.log(name + ' --- ' + age)

// ES6
//对象
const people = {
    name: 'lux',
    age: 20
}
const { name, age } = people
console.log(`${name} --- ${age}`)
//数组
const color = ['red', 'blue']
const [first, second] = color
console.log(first) //'red'
console.log(second) //'blue'

</code></pre>

<h3 id="spread-operator-展开运算符">Spread Operator 展开运算符</h3>

<ul>
  <li>组装对象或者数组</li>
</ul>

<pre><code class="language-javascript">//数组
const color = ['red', 'yellow']
const colorful = [...color, 'green', 'pink']
console.log(colorful) //[red, yellow, green, pink]

//对象
const alp = { fist: 'a', second: 'b'}
const alphabets = { ...alp, third: 'c' }
console.log(alphabets) //{ "fist": "a", "second": "b", "third": "c"
}
</code></pre>

<ul>
  <li>有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项</li>
</ul>

<pre><code class="language-javascript">//数组
    const number = [1,2,3,4,5]
    const [first, ...rest] = number
    console.log(rest) //2,3,4,5
    //对象
    const user = {
        username: 'lux',
        gender: 'female',
        age: 19,
        address: 'peking'
    }
    const { username, ...rest } = user
    console.log(rest) //{"address": "peking", "age": 19, "gender": "female"
</code></pre>

<ul>
  <li>如果有重复的属性名，右边覆盖左边</li>
</ul>

<pre><code class="language-javascript">const first = {
    a: 1,
    b: 2,
    c: 6,
}
const second = {
    c: 3,
    d: 4
}
const total = { ...first, ...second }
console.log(total) // { a: 1, b: 2, c: 3, d: 4 }

</code></pre>

<h3 id="import-和-export">import 和 export</h3>

<ul>
  <li>import导入模块、export导出模块</li>
</ul>

<pre><code class="language-javascript">//全部导入
import people from './example'

//有一种特殊情况，即允许你将整个模块当作单一对象进行导入
//该模块的所有导出都会作为对象的属性存在
import * as example from "./example.js"
console.log(example.name)
console.log(example.age)
console.log(example.getName())

//导入部分
import {name, age} from './example'

// 导出默认, 有且只有一个默认
export default App

// 部分导出
export class App extend Component {};
</code></pre>

<pre><code>1.当用export default people导出时，就用 import people 导入（不带大括号）

2.一个文件里，有且只能有一个export default。但可以有多个export。

3.当用export name 时，就用import { name }导入（记得带上大括号）

4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } 

5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example
</code></pre>

<h3 id="promise">Promise</h3>

<blockquote>
  <p>在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。</p>
</blockquote>

<p>说白了就是用同步的方式去写异步代码。</p>

<pre><code>fetch('/api/todos')
  .then(res =&gt; res.json())
  .then(data =&gt; ({ data }))
  .catch(err =&gt; ({ err }));

</code></pre>

<h3 id="generators">Generators</h3>

<blockquote>
  <p>生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停</p>
</blockquote>

<blockquote>
  <p>当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值</p>
</blockquote>

<pre><code>// 生成器
function *createIterator() {
    yield 1;
    yield 2;
    yield 3;
}

// 生成器能像正规函数那样被调用，但会返回一个迭代器
let iterator = createIterator();

console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
</code></pre>

<blockquote>
  <p>那生成器和迭代器又有什么用处呢？</p>
</blockquote>

<blockquote>
  <p>围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。</p>
</blockquote>

<blockquote>
  <p>生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。</p>
</blockquote>

<blockquote>
  <p>那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的</p>
</blockquote>

<pre><code class="language-javascript">function run(taskDef) { //taskDef即一个生成器函数

// 创建迭代器，让它在别处可用
let task = taskDef();

// 启动任务
let result = task.next();

// 递归使用函数来保持对 next() 的调用
function step() {

    // 如果还有更多要做的
    if (!result.done) {
        result = task.next();
        step();
    }
}

// 开始处理过程
step();

}
</code></pre>

<blockquote>
  <p>生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。</p>
</blockquote>


    </div>

    

    
      <ul class="tag_box inline">
        <li><i class="icon-tags"></i></li>
        
        


  
     
    	<li><a href="/tags.html#Java-ref">Java <span>21</span></a></li>
     
    	<li><a href="/tags.html#Js-ref">Js <span>5</span></a></li>
    
  



      </ul>
    

    <hr>
    
    <ul class="pagination">
      
        <li class="prev"><a href="/2017/12/31/spring-boot-%E5%9D%91%E5%9D%91%E6%B4%BC%E6%B4%BC%E7%9A%84%E5%B0%8F%E8%B7%AF" title="spring-boot 坑坑洼洼的小路">&larr; Previous</a></li>
      
        <li><a href="/archive.html">Archive</a></li>
      
        <li class="next"><a href="/2018/02/03/angular-5%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1" title="angular 5父子组件通信">Next &rarr;</a></li>
      
    </ul>
    <hr>
  </div>
</div>


      <hr>
      <footer>
        <p>
          &copy; 2018 Meedesidy
        </p>
      </footer>
    </div>

    

    <script src="/assets/themes//resources/jquery/jquery.min.js"></script>
    <script src="/assets/themes//resources/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>

