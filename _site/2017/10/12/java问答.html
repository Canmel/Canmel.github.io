
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>JAVA问答</title>
    <meta name="description" content="JAVA问答">
    <meta name="author" content="Meedesidy">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="/assets/themes//resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link rel="shortcut icon"href="/factive.ico">
    <!--[if lt IE 9]>
      <script src="/assets/themes//resources/respond/Respond.min.js"></script>
    <![endif]-->

    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Meedesidy Blog</a>
        </div>

        <div class="collapse navbar-collapse navbar-ex1-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
      	
      	<li><a href="/archive">文档</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags">标签</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      
<div class="page-header">
  <h1>JAVA问答 </h1>
</div>

<div class="row post-full">
  <div class="col-md-12">
    <div class="date">
      <span>12 October 2017</span>
    </div>
    <div class="content">
      <p>[TOC]</p>

<h1 id="java基础">JAVA基础</h1>
<h2 id="--实例方法和静态方法有什么不一样">- 实例方法和静态方法有什么不一样</h2>
<blockquote>
  <ol>
    <li>从调用上来看，实例方法需要使用对象来调用, 静态方法则是由类直接调用的</li>
    <li>在同一个类中，实例方法内部可以直接使用静态方法，但是静态方法中则无法直接调用这个实例方法</li>
    <li>介于实例方法和静态方法的修饰符有差异，这也算是一种不一样吧。另外，实例方法属于对应类的实例的行为，而静态方法是属于类的行为</li>
    <li>静态方法多用作工具类的方法。</li>
  </ol>
</blockquote>

<hr />
<h2 id="--java中的异常有哪几类分别怎么使用">- Java中的异常有哪几类？分别怎么使用</h2>
<blockquote>
  <ol>
    <li>Throwable 类是Java语言中所有错误或异常的超类, Throwable包含了错误(Error)和异常(Excetion两类)</li>
    <li>Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)</li>
    <li>Error是程序无法处理了, 如果OutOfMemoryError、OutOfMemoryError等等, 这些异常发生时, java虚拟机一般会终止线程 .</li>
    <li>运行时异常都是RuntimeException类及其子类,如 NullPointerException、IndexOutOfBoundsException等, 这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉. 这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免</li>
    <li>检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译. 如IOException、SQLException等</li>
  </ol>
</blockquote>

<hr />
<h2 id="--常用的集合类有哪些特点">- 常用的集合类有哪些？特点？</h2>

<p><strong>Java集合如Map、Set、List等所有集合只能存放引用类型数据，它们都是存放引用类型数据的容器，不能存放如int、long、float、double等基础类型的数据。泛型设置基本类型不能通过编译，不设置泛型在加入元素的时候会自动装箱成包装类</strong></p>

<ul>
  <li>
    <p><strong>结构</strong></p>
  </li>
  <li>Collection
    <ul>
      <li>Set            无序，不允许重复
        <ul>
          <li>HashSet：哈希表｜无序｜元素必须实现HashCode()｜</li>
          <li>TreeSet：二差树｜自动排升序</li>
        </ul>
      </li>
      <li>List           有序，可以有重复元素。
        <ul>
          <li>ArrayList：动态数组｜　查询↑　</li>
          <li>LinkedList：链表｜插入和删除↑</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Map　都可以用来存放java对象
    <ul>
      <li>HashMap　异步　不是线程安全的　效率↑　允许空键值｜数组结合链表</li>
      <li>Hashtable 同步　线程安全　效率↓</li>
    </ul>
  </li>
  <li><strong>Set和List对比</strong>
    <blockquote>
      <p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>
    </blockquote>
  </li>
  <li><strong>ArrayList和LinkedList</strong>
    <blockquote>
      <p><code>ArrayList</code>,是数组结构：少用与中间的增删。多用于查询，修改。每次增删元素顺序都会操作每个元素。
<code>LinkedList</code>,是链表结构：多用于中间，开头增删。少用查询，修改。查询时会遍历大量元素。</p>
    </blockquote>
  </li>
</ul>

<h2 id="--集合排序">- 集合排序</h2>
<ul>
  <li>java集合的工具类<strong>Collections</strong>中提供了两种排序的方法,分别是:
    <ol>
      <li><code>Collections.sort(List list)</code>｜自然排序</li>
      <li><code>Collections.sort(List list,Comparator c)</code>｜定制排序｜需要new一个<code>Comparator</code>接口的比较器对象</li>
    </ol>
  </li>
  <li><strong>Map</strong>排序
    <ol>
      <li>
        <table>
          <tbody>
            <tr>
              <td><code>Collections.sort(List list,Comparator)</code></td>
              <td><code>list</code>为<code>Map</code>的键或值的集合</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>使用<code>TreeMap(Comparator comparator)</code>,创建自定义比较器的<code>TreeMap,putAll(map)</code></li>
      <li>遍历排序</li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="--内存溢出是怎么回事">- 内存溢出是怎么回事?</h2>
<blockquote>
  <p>对象有被指向的引用，但是再也用不到它就是内存溢出了。</p>
</blockquote>

<hr />

<h2 id="--和equals的区别">- ==和equals的区别？</h2>

<blockquote>
  <p><code>==</code>判断对象物理地址.<code>equals</code>判断对象<code>Value</code>是否相等。</p>
</blockquote>

<pre><code class="language-java">// java.lang.Object

public boolean equals(Object obj) {
    return (this == obj);
}
</code></pre>

<hr />

<h2 id="--hashcode方法的作用">- hashCode方法的作用？</h2>
<blockquote>
  <p>在hashMap中使用，把一个对象变成一个整型。hashCode规范，如果两个对象的equals返回true，那他们的hashCode必须相等，但是hashCode相等，不一定equals不一定相等。</p>
</blockquote>

<hr />

<h2 id="--object类中有哪些方法列举3个以上">- Object类中有哪些方法？列举3个以上。</h2>
<p>构造方法，<code>toString()</code>，<code>equals</code>，<code>hashCode</code>，<code>getClass</code>,<code>finalize</code>,<code>clone</code>,三个<code>wait()</code>,<code>notify</code>,<code>notifyAll</code>.</p>

<hr />

<h2 id="--nio是什么适用于何种场景">- NIO是什么？适用于何种场景？</h2>
<p>NIO是newIO,接口都是异步的，非阻塞的。</p>

<hr />

<h2 id="--如何实现线程安全的hashmap">- 如何实现线程安全的HashMap？</h2>

<p>线程安全：ConcurrentHashMap(系统自带的线程安全的HashMap),Map&lt;Object, Object&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;&gt;()); synchronizedMap 为线程安全的Map.</p>

<hr />

<h2 id="--java一个字符占多少个字节int-long-double占多少字节">- Java一个字符占多少个字节，int, long, double占多少字节</h2>
<blockquote>
  <p>一个字符两个字节，int 4 , long double 8</p>
</blockquote>

<hr />

<h2 id="--创建一个类的实例都有哪些办法">- 创建一个类的实例都有哪些办法？</h2>
<blockquote>
  <ol>
    <li><code>new Constructor()</code> 最常见的</li>
    <li>Class类的<code>newInstance</code>方法:<code>Student stu = Student.class.newInstance();</code></li>
    <li>java.lang.reflect.Constructor 的newInstance</li>
    <li>调用一个对象的clone方法，JVM就会创建一个新的对象</li>
    <li>使用反序列化,需要让我们的类实现Serializable接口</li>
  </ol>
</blockquote>

<hr />

<h2 id="--finalfinallyfinalize的区别">- final/finally/finalize的区别？</h2>
<ul>
  <li>final是类，变量，方法的修饰。类被修饰后不能再被继承。变量和方法被修饰不能再被修改</li>
  <li>finally是try…catch后执行的finally，</li>
  <li>finalize,在Object中的方法名，在此对象被回收前会执行这个方法。（当使用文件流时，如果对象被回收，没有关闭流，在底层就会实现内存泄露）</li>
</ul>

<h2 id="--sessioncookie的区别">- Session/Cookie的区别？</h2>
<ul>
  <li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
  <li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</li>
  <li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
 考虑到减轻服务器性能方面，应当使用COOKIE。</li>
  <li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</li>
  <li>将登陆信息等重要信息存放为SESSION,其他信息如果需要保留，可以放在COOKIE中</li>
</ul>

<hr />

<h2 id="--servlet的生命周期">- Servlet的生命周期？</h2>
<p>初始化，服务处理（接收请求，处理请求，返回结果），销毁</p>

<hr />

<h1 id="框架使用">框架使用</h1>
<h2 id="--你是怎么理解ioc的">- 你是怎么理解IOC的</h2>
<blockquote>
  <p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。</p>
</blockquote>

<hr />

<h2 id="--你是怎么理解aop的">- 你是怎么理解AOP的</h2>
<blockquote>
  <ol>
    <li>用途:　日志记录，性能统计，安全控制，权限管理，事务处理，异常处理，资源池管理。</li>
    <li>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，</li>
    <li>通过spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。</li>
  </ol>
</blockquote>

<p>下面代码使用AOP设置事物</p>
<pre><code class="language-xml">&lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;
    &lt;!-- 使用注解的包，包括子集 --&gt;
    &lt;context:component-scan base-package="com.eam" /&gt;
    &lt;mvc:annotation-driven /&gt;
 
    &lt;!-- JNDI方式配置数据源 --&gt;
    &lt;!-- &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt; 
        &lt;property name="jndiName" value="${jndiName}"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt;
 
    &lt;!-- 这里Id与SessionContext要同步 --&gt;
    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${driver}" /&gt;
        &lt;property name="url" value="${url}" /&gt;
        &lt;property name="username" value="${username}" /&gt;
        &lt;property name="password" value="${password}" /&gt;
        &lt;property name="maxActive" value="10" /&gt;
    &lt;/bean&gt;
 
    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean name="transactionManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;
 
    &lt;!-- 拦截器方式配置事物 --&gt;
    &lt;tx:advice id="transactionAdvice" transaction-manager="transactionManager"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="add*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="save*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="update*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="modify*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="edit*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="insert*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="delete*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="remove*" propagation="REQUIRED" read-only="false" /&gt;
            &lt;tx:method name="repair" propagation="REQUIRED" read-only="false" /&gt;
 
            &lt;tx:method name="get*" propagation="REQUIRED" read-only="true" /&gt;
            &lt;tx:method name="load*" propagation="REQUIRED" read-only="true" /&gt;
            &lt;tx:method name="find*" propagation="REQUIRED" read-only="true" /&gt;
            &lt;tx:method name="select*" propagation="REQUIRED" read-only="true" /&gt;
            &lt;tx:method name="search*" propagation="REQUIRED" read-only="true" /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id="transactionPointcut"
            expression="execution(* com.eam.service..*Impl.*(..))" /&gt;
        &lt;aop:advisor pointcut-ref="transactionPointcut"
            advice-ref="transactionAdvice" /&gt;
    &lt;/aop:config&gt;
</code></pre>

<hr />

<h2 id="--spring中bean的生命周期">- Spring中Bean的生命周期</h2>
<blockquote>
  <ol>
    <li>实例化一个Bean－－也就是我们常说的new；</li>
    <li>按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；</li>
    <li>如果这个Bean已经实现了<code>BeanNameAware</code>接口，会调用它实现的<code>setBeanName(String)</code>方法</li>
    <li>如果这个Bean已经实现了<code>BeanFactoryAware</code>接口，会调用它实现的<code>setBeanFactory(setBeanFactory(BeanFactory)</code>传递的是Spring工厂自身</li>
    <li>如果这个Bean已经实现了<code>ApplicationContextAware</code>接口，会调用<code>setApplicationContext(ApplicationContext)</code>方法，传入Spring上下文</li>
    <li>如果这个Bean关联了<code>BeanPostProcessor</code>接口，将会调用<code>postProcessBeforeInitialization(Object obj, String s)</code>方法，<code>BeanPostProcessor</code>经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术</li>
    <li>如果Bean在Spring配置文件中配置了<code>init-method</code>属性会自动调用其配置的初始化方法</li>
    <li>如果这个Bean关联了<code>BeanPostProcessor</code>接口，将会调用<code>postProcessAfterInitialization(Object obj, String s)</code>方法</li>
  </ol>
</blockquote>

<p>现在已经可以使用这个bean了, 使用完就可以准备清理了</p>

<blockquote>
  <ol>
    <li>当Bean不再需要时，会经过清理阶段，如果Bean实现了<code>DisposableBean</code>这个接口，会调用那个其实现的<code>destroy()</code>方法</li>
    <li>最后，如果这个Bean的Spring配置中配置了<code>destroy-method</code>属性，会自动调用其配置的销毁方法。</li>
  </ol>
</blockquote>

<h2 id="--spring中有哪三种依赖注入的方式">- Spring中有哪三种依赖注入的方式？</h2>
<ol>
  <li>根据属性注入也叫set方法注入</li>
  <li>根据构造方法注入</li>
  <li>根据注解进行注入（推荐）</li>
</ol>

<hr />

<h2 id="--spring事务的传播属性是怎么回事">- Spring事务的传播属性是怎么回事</h2>
<h3 id="事务传播属性"><strong>事务传播属性</strong>　</h3>
<ol>
  <li>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
  <li>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行</li>
  <li>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</li>
  <li>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</li>
  <li>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
  <li>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
  <li>PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务,则进行与PROPAGATION_REQUIRED类似的操作</li>
</ol>

<h3 id="事务隔离级别"><strong>事务隔离级别</strong></h3>
<ol>
  <li>DEFAULT</li>
  <li>UNCOMMITTED  这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</li>
  <li>COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</li>
  <li>READ  这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)</li>
  <li>SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读</li>
</ol>

<hr />

<h2 id="--spring主要组件">- Spring主要组件</h2>
<ol>
  <li>前端控制器组件（DispatcherServlet）</li>
  <li>处理器组件（Controller）</li>
  <li>处理器映射器组件（HandlerMapping）</li>
  <li>处理器适配器组件（HandlerAdapter）</li>
  <li>拦截器组件（HandlerInterceptor）</li>
  <li>视图解析器组件（ViewResolver）</li>
  <li>视图组件（View）</li>
  <li>数据转换组件（DataBinder）</li>
  <li>消息转换器组件（HttpMessageConverter）</li>
</ol>

<hr />

<h2 id="--spring中beanfactory和factorybean有什么区别">- Spring中BeanFactory和FactoryBean有什么区别？</h2>
<ul>
  <li>BeanFactory，以Factory结尾，表示它是一个工厂类(接口)，用于管理Bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</li>
  <li>以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean<T>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。</T></li>
</ul>

<hr />

<h2 id="--spring框架中ioc的原理是什么">- Spring框架中IOC的原理是什么</h2>
<ul>
  <li>IoC是<code>Inversion of Control</code>的缩写</li>
  <li><code>获得依赖对象的过程被反转了</code></li>
  <li>其原理是基于面向对象(OO)设计原则</li>
  <li>所有的组件都是被动的，所有的组件初始化和调用都由容器负责</li>
  <li>组件处在一个容器当中，由容器负责管理</li>
</ul>

<blockquote>
  <p>简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控，即在一个类中调用另外一个类。这也就是所谓“控制反转”的概念所在：控制权由应用代码中转到了外部容器，控制权的转移，即所谓反转。</p>
</blockquote>

<hr />
<h2 id="--spring-如何实现数据库事务">- Spring 如何实现数据库事务</h2>

<ul>
  <li>编程式事务管理：需要手动编写代码，在实际开发中很少使用</li>
  <li>声明式事务管理：
    <ul>
      <li>基于<code>TransactionProxyFactoryBean</code>的方式，需要为每个进行事务管理的类做相应配置</li>
      <li>基于AspectJ的XML方式，不需要改动类，在XML文件中配置好即可</li>
      <li>基于注解的方式，配置简单，需要在业务层类中添加注解</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="--mybatis编程步骤是什么样的">- MyBatis编程步骤是什么样的</h2>
<ol>
  <li>创建<code>SqlSessionFactory</code></li>
  <li>通过<code>SqlSessionFactory</code>创建<code>SqlSession</code></li>
  <li>通过<code>sqlsession</code>执行数据库操作</li>
  <li>调用<code>session.commit()</code>提交事务</li>
  <li>调用<code>session.close()</code>关闭会话</li>
</ol>

<h2 id="--使用mybatis的mapper接口调用时有哪些要求">- 使用MyBatis的mapper接口调用时有哪些要求</h2>
<ol>
  <li>Mapper接口方法名和<code>mapper.xml</code>中定义的每个sql的id相同</li>
  <li>Mapper接口方法的输入参数类型和<code>mapper.xml</code>中定义的每个sql 的<code>parameterType</code>的类型相同</li>
  <li>Mapper接口方法的输出参数类型和<code>mapper.xml</code>中定义的每个sql的<code>resultType</code>的类型相同</li>
  <li><code>Mapper.xml</code>文件中的<code>namespace</code>即是mapper接口的类路径</li>
</ol>

<h2 id="--springmvc工作流程">- SpringMVC工作流程</h2>
<ol>
  <li>用户发送请求至前端控制器<code>DispatcherServlet</code></li>
  <li><code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code>处理器映射器</li>
  <li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<code>DispatcherServlet</code></li>
  <li><code>DispatcherServlet</code>调用<code>HandlerAdapter</code>处理器适配器</li>
  <li><code>HandlerAdapter</code>经过适配调用具体的处理器(Controller，也叫后端控制器)</li>
  <li><code>Controller</code>执行完成返回<code>ModelAndView</code></li>
  <li><code>HandlerAdapter</code>将<code>controller</code>执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code></li>
  <li><code>DispatcherServlet</code>将<code>ModelAndView</code>传给<code>ViewReslover</code>视图解析器</li>
  <li><code>ViewReslover</code>解析后返回具体<code>View</code></li>
  <li><code>DispatcherServlet</code>根据View进行渲染视图（即将模型数据填充至视图中）</li>
  <li><code>DispatcherServlet</code>响应用户</li>
</ol>

<hr />

<h2 id="--mybatis-和的区别是什么">- MyBatis #{}和${}的区别是什么？</h2>

<blockquote>
  <p>${}是变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值</p>
</blockquote>

<hr />

<h2 id="--xml映射文件中除了常见的selectinsertupdaedelete标签之外还有哪些标签">- Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h2>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态sql的9个标签，<code>trim</code></td>
        <td><code>where</code></td>
        <td><code>set</code></td>
        <td><code>foreach</code></td>
        <td><code>if</code></td>
        <td><code>choose</code></td>
        <td><code>when</code></td>
        <td><code>otherwise</code></td>
        <td><code>bind</code>等，其中<sql>为sql片段标签，通过`<include>`标签引入sql片段，`<selectKey>`为不支持自增的主键生成策略标签。</selectKey></include></sql></td>
      </tr>
    </tbody>
  </table>
</blockquote>

<hr />
<h2 id="--mybatis-分页原理">- MyBatis 分页原理</h2>
<blockquote>
  <p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
</blockquote>

<h2 id="--mybatis-分页插件的原理是什么">- MyBatis 分页插件的原理是什么？</h2>
<blockquote>
  <p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
</blockquote>

<h1 id="数据库相关">数据库相关</h1>

<h2 id="--乐观锁和悲观锁的区别">- 乐观锁和悲观锁的区别？</h2>
<blockquote>
  <p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p>
</blockquote>

<blockquote>
  <p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
</blockquote>

<p><strong>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</strong></p>

<hr />

<h2 id="--索引数据结构">- 索引数据结构</h2>
<p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构</strong>。</p>

<blockquote>
  <p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
</blockquote>

<p>二叉树？？</p>

<hr />

<h2 id="--如何优化数据库性能">- 如何优化数据库性能</h2>
<ol>
  <li>表的设计合理化(符合3NF)</li>
  <li>添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]</li>
  <li>分表技术(水平分割、垂直分割)</li>
  <li>读写[写: update/delete/add]分离</li>
  <li>存储过程 [模块化编程，可以提高速度]</li>
  <li>对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]</li>
  <li>mysql服务器硬件升级</li>
  <li>定时的去清除不需要的数据,定时进行碎片整理(MyISAM)</li>
</ol>

<h2 id="--数据库索引">- 数据库索引</h2>

<p><strong>适合建立索引的列</strong></p>

<ul>
  <li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>
  <li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li>
  <li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>
  <li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
  <li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度</li>
</ul>

<p><strong>不适合建立索引的列</strong></p>

<ul>
  <li>对于那些在查询中很少使用或者参考的列不应该创建索引</li>
  <li>对于那些只有很少数据值的列也不应该增加索引</li>
  <li>对于那些定义为text, image和bit数据类型的列不应该增加索引</li>
</ul>

<p><strong>优点</strong></p>

<ul>
  <li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
  <li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因</li>
  <li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li>
  <li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间- 表字段的类型选择要恰当</li>
  <li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
  <li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
  <li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li>
  <li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li>
</ul>

<hr />

<h2 id="--sql中索引不会被用到的几种情况">- sql中索引不会被用到的几种情况</h2>
<ol>
  <li>查询谓词没有使用索引的主要边界,换句话说就是select *，可能会导致不走索引。</li>
  <li>单键值的b树索引列上存在null值，导致COUNT(*)不能走索引。</li>
  <li>索引列上有函数运算，导致不走索引</li>
  <li>隐式转换导致不走索引。</li>
  <li>表的数据库小或者需要选择大部分数据，不走索引</li>
  <li>cbo优化器下统计信息不准确，导致不走索引</li>
  <li>！=或者&lt;&gt;(不等于），可能导致不走索引，也可能走 INDEX FAST FULL SCAN</li>
  <li>表字段的属性导致不走索引，字符型的索引列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式，</li>
</ol>

<h2 id="--mybatis批量插入返回主键">- Mybatis批量插入返回主键</h2>
<pre><code class="language-xml">&lt;insert id="insertAuthor" useGeneratedKeys="true"
    keyProperty="id"&gt;
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
&lt;/insert&gt;
</code></pre>
<h2 id="--mybatis中dao工作原理">- MyBatis中Dao工作原理</h2>
<blockquote>
  <p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p>
</blockquote>

<blockquote>
  <p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
</blockquote>

<blockquote>
  <p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
</blockquote>

<hr />

<h2 id="--mybatis对象关系">- MyBatis对象关系</h2>
<ol>
  <li>association  一对一关联查询</li>
  <li>collection  一对多关联查询</li>
</ol>

<hr />

<h1 id="网络协议和网络编程">网络协议和网络编程</h1>

<hr />

<h1 id="redis等缓存系统中间件nosql一致性hash等">Redis等缓存系统/中间件/NoSQL/一致性Hash等</h1>

<hr />

<h1 id="设计模式与重构">设计模式与重构</h1>
<h2 id="--单例模式">- 单例模式？</h2>
<ul>
  <li>懒汉模式  …</li>
  <li>饿汉模式  …</li>
</ul>

<hr />

<h2 id="--工厂模式">- 工厂模式</h2>

<hr />

<h2 id="--代理模式">- 代理模式</h2>
<ul>
  <li>静态代理</li>
  <li>动态代理</li>
</ul>

<hr />

<h1 id="数据结构与算法基础">数据结构与算法基础</h1>

<h2 id="--集合">- 集合</h2>

<ul>
  <li>
    <p><strong>结构</strong>
Collection
|Set            无序，不允许重复
||————HashSet：哈希表｜无序｜元素必须实现HashCode()｜
||————TreeSet：二差树｜自动排升序 
|List           有序，可以有重复元素。
||————ArrayList：动态数组｜　查询↑　
||————LinkedList：链表｜插入和删除↑
Map　都可以用来存放java对象
|————HashMap　异步　不是线程安全的　效率↑　允许空键值｜数组结合链表
|————Hashtable 同步　线程安全　效率↓</p>
  </li>
  <li><strong>Set和List对比</strong>
    <blockquote>
      <p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>
    </blockquote>
  </li>
  <li><strong>ArrayList和LinkedList</strong>
    <blockquote>
      <p><code>ArrayList</code>,是数组结构：少用与中间的增删。多用于查询，修改。每次增删元素顺序都会操作每个元素。
<code>LinkedList</code>,是链表结构：多用于中间，开头增删。少用查询，修改。查询时会遍历大量元素。</p>
    </blockquote>
  </li>
</ul>

<hr />
<h2 id="--hashmap">- HashMap</h2>
<ul>
  <li>特点
    <blockquote>
      <ol>
        <li>HashMap可以接受null键值和值，而Hashtable则不能</li>
        <li>HashMap非synchronized</li>
        <li>使用put()存储, 使用get(key)获取,put()方法在<code>AbstractHashedMap.class</code>中实现,先获取hash,通过hashcode在entry中查找,<code>if (entry.hashCode == hashCode &amp;&amp; isEqualKey(key, entry.key))</code>查找是否存在,没找到就插入一条</li>
      </ol>
    </blockquote>
  </li>
</ul>

<h3 id="为什么string-interger这样的wrapper类适合作为键">为什么String, Interger这样的wrapper类适合作为键？</h3>
<blockquote>
  <p>String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，都是final的，而且已经重写了equals()和hashCode()方法了</p>
</blockquote>

<h2 id="--arraylist">- ArrayList</h2>
<ul>
  <li><strong>排序</strong>　
    <ul>
      <li>Collections.sort()</li>
      <li>Collections.sort(list,comparator)</li>
    </ul>
  </li>
</ul>

<h2 id="--treeset">- TreeSet</h2>

<ul>
  <li><strong>排序</strong>　
    <ul>
      <li>Collections.sort()</li>
      <li>Collections.sort(list,comparator)</li>
      <li>自带排序</li>
      <li>构造器定制</li>
    </ul>
  </li>
</ul>

<h2 id="--hashset">- HashSet</h2>

<blockquote>
  <p>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，更确切的说，HashSet中的元素，只是存放在了底层HashMap的key上， 而value使用一个static final的Object对象标识。因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成</p>
</blockquote>

<hr />

<h1 id="jvm">JVM</h1>
<h2 id="--jvm内存结构">- JVM内存结构</h2>

<ul>
  <li>Java堆（Heap）:
    <ul>
      <li>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块,几乎所有的对象实例都在这里分配内存</li>
      <li>Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</li>
      <li>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</li>
    </ul>
  </li>
  <li>方法区（Method Area）
    <ul>
      <li>各个线程共享的内存区域,<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>,别名<strong>Non-Heap（非堆）(永久代)</strong></li>
      <li>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</li>
    </ul>
  </li>
  <li>程序计数器（Program Counter Register）
    <ul>
      <li>一块较小的内存空间</li>
      <li>它的作用可以看做是当前线程所执行的字节码的行号指示器</li>
    </ul>
  </li>
  <li>JVM栈（JVM Stacks）
    <ul>
      <li>线程私有</li>
      <li>它的生命周期与线程相同</li>
      <li>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
      <li>当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</li>
      <li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li>
    </ul>
  </li>
  <li>本地方法栈（Native Method Stacks）
    <ul>
      <li>与虚拟机栈所发挥的作用是非常相似的</li>
      <li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</li>
    </ul>
  </li>
</ul>

<h1 id="开放性问题">开放性问题</h1>

    </div>

    

    
      <ul class="tag_box inline">
        <li><i class="icon-tags"></i></li>
        
        


  
     
    	<li><a href="/tags.html#Java-ref">Java <span>20</span></a></li>
    
  



      </ul>
    

    <hr>
    
    <ul class="pagination">
      
        <li class="prev"><a href="/2017/10/10/Spring%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8" title="Spring使用实体接收参数异常">&larr; Previous</a></li>
      
        <li><a href="/archive.html">Archive</a></li>
      
        <li class="next"><a href="/2017/11/07/HttpClient%E5%90%84%E7%89%88%E6%9C%AC%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" title="HttpClient各版本发送请求">Next &rarr;</a></li>
      
    </ul>
    <hr>
  </div>
</div>


      <hr>
      <footer>
        <p>
          &copy; 2017 Meedesidy
        </p>
      </footer>
    </div>

    

    <script src="/assets/themes//resources/jquery/jquery.min.js"></script>
    <script src="/assets/themes//resources/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>

