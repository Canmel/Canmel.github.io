<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Meedesidy Blog</title>
 <link href="http://canmel.github.io/" rel="self"/>
 <link href="http://canmel.github.io"/>
 <updated>2017-08-23T17:13:57+08:00</updated>
 <id>http://canmel.github.io</id>
 <author>
   <name>Meedesidy</name>
   <email>892379244@qq.com</email>
 </author>

 
 <entry>
   <title>spring cloud 源码分析</title>
   <link href="http://canmel.github.io/2017/08/23/spring-cloud"/>
   <updated>2017-08-23T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/08/23/spring-cloud-</id>
   <content type="html">
&lt;h3 id=&quot;注解enablediscoveryclient&quot;&gt;注解　@EnableDiscoveryClient&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;功能: 开启一个&lt;code&gt;DiscoveryClient&lt;/code&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;####　org.springframework.cloud.client.discovery.DiscoveryClient
定义了用来发现服务的常用抽象方法，所以使用&lt;code&gt;spring cloud&lt;/code&gt; 构建的微服务可以方便的切换不同的服务治理框架，而不需要改动代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface DiscoveryClient {

	/**
	 * A human readable description of the implementation, used in HealthIndicator
	 * @return the description
	 */
	public String description();

	/**
	 * @return ServiceInstance with information used to register the local service
	 */
	public ServiceInstance getLocalServiceInstance();

	/**
	 * Get all ServiceInstances associated with a particular serviceId
	 * @param serviceId the serviceId to query
	 * @return a List of ServiceInstance
	 */
	public List&amp;lt;ServiceInstance&amp;gt; getInstances(String serviceId);

	/**
	 * @return all known service ids
	 */
	public List&amp;lt;String&amp;gt; getServices();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;orgspringframeworkcloudnetflixeurekaeurekadiscoveryclient&quot;&gt;org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient&lt;/h4&gt;
&lt;p&gt;是&lt;code&gt;DiscoveryClient&lt;/code&gt;接口的一个实现，从命名来看，他是&lt;code&gt;Eureka&lt;/code&gt;发现服务的封装，所以&lt;code&gt;EurekaDiscoveryClient&lt;/code&gt;依赖&lt;code&gt;Eureka&lt;/code&gt;的服务接口&lt;code&gt;com.netflix.discovery.EurekaClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;EurekaClient&lt;/code&gt;的类注释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; * EurekaClient API contracts are:
 *  - provide the ability to get InstanceInfo(s) (in various different ways)
 *  - provide the ability to get data about the local Client (known regions, own AZ etc)
 *  - provide the ability to register and access the healthcheck handler for the client
 *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EurekaClient　API 负责的任务：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;提供通过各种不同的方式获取实例（服务）信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;提供获取本地client（服务）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;检查登记处理程序的client(服务)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;comnetflixdiscoverysharedlookupservice&quot;&gt;com.netflix.discovery.shared.LookupService&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;寻找服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;comnetflixdiscoverydiscoveryclient&quot;&gt;com.netflix.discovery.DiscoveryClient&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Eureka&lt;/code&gt; 真正用来发现服务的类&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个类帮助与&lt;code&gt;Eureka Service&lt;/code&gt;相互协作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Eureka Service&lt;/code&gt; 负责下面的任务：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;向&lt;code&gt;Eureka Service&lt;/code&gt;注册服务实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;向&lt;code&gt;Eureka Service&lt;/code&gt;服务租约&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;当服务关闭期间，向&lt;code&gt;Eureka Service&lt;/code&gt;取消租约&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;查询&lt;code&gt;Eureka Service&lt;/code&gt;中的服务实例列表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Eureka Client&lt;/code&gt;还需要一个&lt;code&gt;Eureka Service&lt;/code&gt;的&lt;code&gt;URL&lt;/code&gt;列表&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>java 8 新特性</title>
   <link href="http://canmel.github.io/2017/08/23/java-8-%E6%96%B0%E7%89%B9%E6%80%A7"/>
   <updated>2017-08-23T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/08/23/java-8-新特性</id>
   <content type="html">
&lt;h3 id=&quot;1-default方法defender方法&quot;&gt;1. default方法（defender方法）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface BaseInterface {
  public void doSomeWork();
}

class SimpleInterfaceImpl implements BaseInterface{
  @Override
  public void doSomeWork() {
    System.out.println(&quot;Do Some Work implementation in the class&quot;);
  }
 
  public static void main(String[] args) {
    SimpleInterfaceImpl simpObj = new SimpleInterfaceImpl();
    simpObj.doSomeWork();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要向上面的接口添加新方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface BaseInterface {
  public void doSomeWork();
  public void doSomeOtherWork();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行会得到&lt;code&gt;SimpleInterfaceImpl&lt;/code&gt; 不是一个抽象类或没有重写&lt;code&gt;doSomeOtherWork()&lt;/code&gt;这个抽象方法&lt;/p&gt;

&lt;p&gt;所以要直接改变/拓展一个接口内部方法变得困难,在尝试强化&lt;code&gt;java 8 Collections API&lt;/code&gt; 让其支持&lt;code&gt;lambda&lt;/code&gt;表达式的时候，就面临了这样的挑战,为了克服这个困难，&lt;code&gt;Java 8&lt;/code&gt;中引入了一个新的概念，叫做&lt;code&gt;default&lt;/code&gt;方法，也可以称为&lt;code&gt;Defender&lt;/code&gt;方法，或者&lt;code&gt;虚拟扩展方法&lt;/code&gt;（&lt;code&gt;Virtual extension methods)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如： in java.util&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;default void replaceAll(UnaryOperator&amp;lt;E&amp;gt; operator) {
    Objects.requireNonNull(operator);
    final ListIterator&amp;lt;E&amp;gt; li = this.listIterator();
    while (li.hasNext()) {
        li.set(operator.apply(li.next()));
    }
}

default void sort(Comparator&amp;lt;? super E&amp;gt; c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator&amp;lt;E&amp;gt; i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Spring cloud application.properties</title>
   <link href="http://canmel.github.io/2017/08/22/spring-cloud-applicationproperties"/>
   <updated>2017-08-22T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/08/22/spring-cloud-applicationproperties</id>
   <content type="html">
&lt;ul&gt;
  &lt;li&gt;server:
    &lt;ul&gt;
      &lt;li&gt;port:                 &lt;code&gt;服务端口&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;spring:
    &lt;ul&gt;
      &lt;li&gt;application:
        &lt;ul&gt;
          &lt;li&gt;name:             &lt;code&gt;服务名称，&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;eureka:
    &lt;ul&gt;
      &lt;li&gt;client:
        &lt;ul&gt;
          &lt;li&gt;serviceUrl:
            &lt;ul&gt;
              &lt;li&gt;defaultZone:  &lt;code&gt;服务注册中心地址&lt;/code&gt;
  为了安全很多时候都会为服务注册中心加上安全校验配置serviceUrl加上Url加上安全校验信息，比如&lt;code&gt;http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@localhost:1111/eureka/&lt;/code&gt;
  其中&lt;code&gt;username&lt;/code&gt;是安全校验信息用户名，&lt;code&gt;password&lt;/code&gt;为该用户的密码&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;register-with-eureka: &lt;code&gt;默认true, 启动时想注册机注册自己&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;fetch-registry:   &lt;code&gt;检索服务　默认true&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;registry-fetch-interval-seconds: &lt;code&gt;获取只读服务列表的时间间隔默认３０秒, 前提是fetch-registry　不为false&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;instance:
        &lt;ul&gt;
          &lt;li&gt;hostname:         &lt;code&gt;主机名&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;lease-renewal-interval-in-seconds: &lt;code&gt;服务续约任务的调用时间　默认30秒&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;lease-expiration-duration-in-seconds: &lt;code&gt;定义服务失效时间　默认90秒&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;server:
        &lt;ul&gt;
          &lt;li&gt;enable-self-preservation: &lt;code&gt;保护机制(检测实例心跳链接: 15分组低于85%)　默认true&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>ubuntu安装java开发环境</title>
   <link href="http://canmel.github.io/2017/08/21/ubuntu%E5%AE%89%E8%A3%85jdk"/>
   <updated>2017-08-21T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/08/21/ubuntu安装jdk</id>
   <content type="html">
&lt;h3 id=&quot;添加ppa更新&quot;&gt;添加ppa,更新&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;~ sudo add-apt-repository ppa:webupd8team/java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;~ sudo apt-get update&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###　安装oracle-java-installer&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jdk7
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo apt-get install oracle-java7-installer&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;jdk8
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo apt-get install oracle-java8-installer&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;安装器会提示你同意 oracle 的服务条款,选择 ok,然后选择yes 即可
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;设置系统默认jdk&quot;&gt;设置系统默认jdk&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JDk7
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-7-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;JDk8
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-8-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;切换jdk版本&quot;&gt;切换jdk版本&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;jdk8 切换到jdk7
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-7-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;jdk7 切换到jdk8
    &lt;blockquote&gt;
      &lt;p&gt;~ sudo update-java-alternatives -s java-8-oracle&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;测试jdk-是是否安装成功&quot;&gt;测试jdk 是是否安装成功&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;~ java -version
~ javac -version&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>在阿里云服务器使用docker部署web项目</title>
   <link href="http://canmel.github.io/2017/08/20/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8docker%E5%8F%91%E5%B8%83web%E9%A1%B9%E7%9B%AE"/>
   <updated>2017-08-20T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/08/20/阿里云服务器使用docker发布web项目</id>
   <content type="html">&lt;h2 id=&quot;在阿里云服务器使用docker部署web项目&quot;&gt;在阿里云服务器使用docker部署web项目&lt;/h2&gt;
&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;github 帐号，创建新的&lt;code&gt;repository&lt;/code&gt;,并将代码push到这个&lt;code&gt;repository&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;阿里云服务器&lt;/li&gt;
  &lt;li&gt;注册&lt;code&gt;daocloud&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ssh登录远程服务器&quot;&gt;ssh登录远程服务器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;~ ssh root@99.99.99.99 &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安装docker&quot;&gt;安装docker&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;可以借鉴 &lt;a href=&quot;http://blog.csdn.net/mickjoust/article/details/51578629&quot;&gt;Ubuntu 16.04安装使用Docker &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Rails中的ActiveSupport</title>
   <link href="http://canmel.github.io/2017/07/17/Rails%E4%B8%AD%E7%9A%84ActiveSupport"/>
   <updated>2017-07-17T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/07/17/Rails中的ActiveSupport</id>
   <content type="html">&lt;h2 id=&quot;rails中的activesupport&quot;&gt;Rails中的ActiveSupport&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rails::Railtie is the core of the Rails framework and provides several hooks to extend Rails and/or modify the initialization process.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Rails::Railties 是Rails框架核心，并提供了几个钩子扩展Rails和/或修改初始化过程。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;得到gem&quot;&gt;得到gem&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;rails new appname&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Rails::Railties 是Rails框架核心,创建rails程序,&lt;code&gt;External Libraries&lt;/code&gt;　中会看到　&lt;code&gt;Railties&lt;/code&gt;的gem&lt;/p&gt;

&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;rails s&lt;/code&gt; , 是程序开始的地方&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先会执行　&lt;code&gt;RUBY_PATH/bin/rails&lt;/code&gt;, 具体是这个样子的：&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; #!/usr/bin/env ruby
 #
 # This file was generated by RubyGems.
 #
 # The application 'railties' is installed as part of a gem, and
 # this file is here to facilitate running it.
 #
    
 require 'rubygems'
    
 version = &quot;&amp;gt;= 0.a&quot;
    
 if ARGV.first
   str = ARGV.first
   str = str.dup.force_encoding(&quot;BINARY&quot;) if str.respond_to? :force_encoding
   if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
     version = $1
     ARGV.shift
   end
 end
    
 gem 'railties', version
 load Gem.bin_path('railties', 'rails', version)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着执行　&lt;code&gt;load Gem.bin_path('railties', 'rails', version)&lt;/code&gt;(文件在&lt;code&gt;RUBY_PATH/rubygems.rb&lt;/code&gt;), 加载gem包下可执行文件&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;加载的gem包含&lt;code&gt;ActiveSupport&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;ActiveSupport&lt;/code&gt;中定义了很多类和方法，如：　&lt;code&gt;lib/active_support/core_ext/object/blank.rb&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; class NilClass
   # +nil+ is blank:
   #
   #   nil.blank? # =&amp;gt; true
   #
   # @return [true]
   def blank?
     true
   end
 end
&lt;/code&gt;&lt;/pre&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;这样就可以得到&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;irb(main):001:0&amp;gt; nil.blank? =&amp;gt; true`&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Rails中什么时候需要require</title>
   <link href="http://canmel.github.io/2017/07/17/Rails%E4%B8%AD%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E9%9C%80%E8%A6%81require"/>
   <updated>2017-07-17T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/07/17/Rails中什么地方需要require</id>
   <content type="html">&lt;h2 id=&quot;rails中什么时候需要require&quot;&gt;Rails中什么时候需要require&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Scene&lt;/code&gt;&lt;/strong&gt;  在现在的ROR开发中，比如在用户的控制器中使用下面一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class UsersController &amp;lt; ApplicationController
  def test
    p User.name
  end
end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Qustion&lt;/code&gt;&lt;/strong&gt; 然而在&lt;code&gt;Controller&lt;/code&gt;中并没有任何的&lt;code&gt;require&lt;/code&gt;或者&lt;code&gt;import&lt;/code&gt;或者&lt;code&gt;include&lt;/code&gt;等动作，那&lt;code&gt;User&lt;/code&gt;类是怎么加载到&lt;code&gt;controller&lt;/code&gt;中的呢？&lt;/p&gt;

&lt;h3 id=&quot;整理这个问题的时候我顺便找到了关于-ruby-内核类加载机制-&quot;&gt;整理这个问题的时候,我顺便找到了关于 &lt;a href=&quot;http://www.baidu.com&quot;&gt;Ruby 内核类加载机制 &lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;load_path&quot;&gt;$LOAD_PATH&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在&lt;code&gt;Rails&lt;/code&gt;项目中有很多第三方库，如果要对第三方库和业务代码进行管理，即&lt;code&gt;$LOAD_PATH&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Ruby&lt;/code&gt;并不要求统一管理类，理论上我们的类文件可以遍布整个系统各个角落，意味着我们需要为每个文件制定一个绝对路径活着相对路径&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$LOAD_PATH&lt;/code&gt;是一个字符串数组，元素是一堆路径
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt; $:
  =&amp;gt; [&quot;/home/baily/.rbenv/plugins/rbenv-gem-rehash&quot;, &quot;/home/baily/.rbenv/rbenv.d/exec/gem-rehash&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/gems/2.3.0/gems/did_you_mean-1.0.0/lib&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/site_ruby/2.3.0&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/site_ruby/2.3.0/x86_64-linux&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/site_ruby&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/vendor_ruby/2.3.0&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/vendor_ruby/2.3.0/x86_64-linux&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/vendor_ruby&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/2.3.0&quot;, &quot;/home/baily/.rbenv/versions/2.3.1/lib/ruby/2.3.0/x86_64-linux&quot;]
  irb(main):002:0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;这样就可以很方便对类库进行管理，和新类库的添加
    &lt;blockquote&gt;
      &lt;p&gt;$:.unshift File.dirname(&lt;strong&gt;FILE&lt;/strong&gt;) //添加新路径&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ruby-kernel-中的类加载&quot;&gt;Ruby Kernel 中的类加载&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Ruby 内核提供了 4 个类加载命令，分别是 load, autoload, require, require_relative, 分别对应了不同的使用场景&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;load(filename, wrap=false):&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;每次重新加载整个文件，成功返回true,失败抛出异常，wrap为true时，被加载文件会在一个匿名模块中执行，避免污染；&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;autoload(module, filename):&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;将filename与module关联，当第一次使用module时，使用require加载该文件;成功返回nil,失败抛出异常&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;require(name):
    &lt;blockquote&gt;
      &lt;p&gt;函数执行时，如果name是绝对路径，则会去查找该文件；通常name是相对路径，需要$:.unshift添加搜索路径；,Ruby会在$:中的目录中搜索该文件,第一次加载返回true，已经加载返回false，找不到文件会抛出LoadError&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;require_relative(filename):
    &lt;blockquote&gt;
      &lt;p&gt;直接取相对路径。此时与$LOAD_PATH($:)无关，是文件本身路径的相对地址&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;activesupport-对内核类加载的扩展&quot;&gt;ActiveSupport 对内核类加载的扩展&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Active Support 是 Rails 裡的工具函式庫，它也擴充了一些 Ruby 標準函式庫。除了被用在 Rails 核心程式中，你也可以在你的程式中使用&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;autoload-扩展&quot;&gt;autoload 扩展&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;除了&lt;code&gt;ActiveSupport&lt;/code&gt;对gem的扩展，在&lt;code&gt;Rails&lt;/code&gt;中，维护了一个类似&lt;code&gt;$LOAD_PATH&lt;/code&gt;的变量&lt;code&gt;autoload_paths&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rails 3 中默认会将 &lt;code&gt;app&lt;/code&gt; 下的子目录以及 lib 目录全部加入 &lt;code&gt;autoload_paths&lt;/code&gt;, Rails 4 中去掉了 lib.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以下是一个刚生成的 Rails 3 项目的 &lt;code&gt;autoload&lt;/code&gt; 路径:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ bin/rails r 'puts ActiveSupport::Dependencies.autoload_paths'
  .../app/assets
  .../app/controllers
  .../app/helpers
  .../app/mailers
  .../app/models
  .../app/controllers/concerns
  .../app/models/concerns
  .../test/mailers/previews
  .../lib
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Rails 中还可以添加自定义的 autoload 路径:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  # config/application.rb
  config.autoload_paths &amp;lt;&amp;lt; &quot;#{Rails.root}/something&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;autoload_paths&lt;/code&gt; 实际上是在 &lt;code&gt;ActiveSupport::Dependencies.autoload_paths&lt;/code&gt; 中定义的, 这是一个 &lt;code&gt;String Array&lt;/code&gt;, 可见 &lt;code&gt;Rails&lt;/code&gt; 的 &lt;code&gt;autoload&lt;/code&gt; 本质上是 &lt;code&gt;ActiveSupport&lt;/code&gt; 的 &lt;code&gt;autoload&lt;/code&gt; 机制&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以下代码将当前目录加入&lt;code&gt;autoload_paths&lt;/code&gt;, 这样在&lt;code&gt;Ruby&lt;/code&gt;找不到某个常量定义的时候，&lt;code&gt;ActiveSupport&lt;/code&gt;就会尝试找到常量定义文件并自动加载.
    &lt;pre&gt;&lt;code&gt;  ActiveSupport::Dependencies.autoload_paths &amp;lt;&amp;lt; '.'
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;到这里&lt;code&gt;rails&lt;/code&gt;项目中就可以在业务代码中互相访问了, 在&lt;code&gt;autoload_path&lt;/code&gt;中没有包含的路径，则需要添加&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;查询&lt;code&gt;autoload_path&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;bin/rails r ‘puts ActiveSupport::Dependencies.autoload_paths’ # 查询autoload_path&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;添加&lt;code&gt;autoload_path&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;config.autoload_paths « ”#{Rails.root}/something” # 添加autoload_path&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;也可以在代码中添加&lt;code&gt;require&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;require ‘../test.rb’ # 如果name是绝对路径，则会去查找该文件；通常name是相对路径，需要$:.unshift添加搜索路径；&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Answer&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;User&lt;/code&gt;加载到&lt;code&gt;UsersController&lt;/code&gt;是通过&lt;code&gt;Rails&lt;/code&gt;的扩展库&lt;code&gt;ActiveSupport&lt;/code&gt;维护的一个类似&lt;code&gt;$LOAD_PATH&lt;/code&gt;的一个变量&lt;code&gt;autoload_path&lt;/code&gt;管理文件的&lt;code&gt;load&lt;/code&gt;之类的行为,他默认路径包含&lt;code&gt;app/&lt;/code&gt;之下的几个文件夹(受rails版本，可能不相同)，&lt;code&gt;/controller&lt;/code&gt;和&lt;code&gt;model&lt;/code&gt;在其中，所以可以在&lt;code&gt;controller&lt;/code&gt;中访问&lt;code&gt;model&lt;/code&gt;信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;也就是说在&lt;code&gt;rails3&lt;/code&gt;以下路径下都是不用&lt;code&gt;include&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;这类行为，就可以使用
    &lt;pre&gt;&lt;code&gt;  .../app/assets
  .../app/controllers
  .../app/helpers
  .../app/mailers
  .../app/models
  .../app/controllers/concerns
  .../app/models/concerns
  .../test/mailers/previews
  .../lib
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;而在&lt;code&gt;autoload_path&lt;/code&gt;中不包含的路径就需要手动&lt;code&gt;require&lt;/code&gt;,像这样：
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  ## Rails 5
  class UsersController &amp;lt; ApplicationController::Base
    # rails的autoload没有lib的路径
    # $LOAD_PATH中 $: 中有lib的路径，所以不需要require全路径
    require 'util/myutil'
  end
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>ruby中String和symbol的区别</title>
   <link href="http://canmel.github.io/2017/07/13/ruby%E4%B8%ADString%E5%92%8Csymbol%E7%9A%84%E5%8C%BA%E5%88%AB"/>
   <updated>2017-07-13T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/07/13/ruby中String和symbol的区别</id>
   <content type="html">&lt;h2 id=&quot;ruby中string和symbol的区别&quot;&gt;ruby中String和symbol的区别&lt;/h2&gt;
&lt;h3 id=&quot;symbol&quot;&gt;Symbol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;定义：Ruby 是一个强大的面向对象脚本语言（本文所用 Ruby 版本为1.8.6），在 Ruby 中 Symbol 表示“名字”，比如字符串的名字，标识符的名字。&lt;/li&gt;
  &lt;li&gt;创建：创建一个 Symbol 对象的方法是在名字或者字符串前面加上冒号：
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt; :foo
  =&amp;gt; :foo
  irb(main):002:0&amp;gt; :test
  =&amp;gt; :test
  irb(main):004:0&amp;gt; :&quot;foo is string&quot;
  =&amp;gt; :&quot;foo is string&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;h3 id=&quot;string&quot;&gt;String&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;定义：Ruby 中的 String 对象用于存储或操作一个或多个字节的序列。&lt;/li&gt;
  &lt;li&gt;创建：Ruby 字符串分为单引号字符串（’）和双引号字符串（”），区别在于双引号字符串能够支持更多的转义字符。
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):007:0&amp;gt; &quot;这是一个字符串&quot;
  =&amp;gt; &quot;这是一个字符串&quot;
  irb(main):008:0&amp;gt; '这也是一个字符串'
  =&amp;gt; &quot;这也是一个字符串&quot;

&lt;/code&gt;&lt;/pre&gt;
    &lt;h3 id=&quot;区别&quot;&gt;区别&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;因为在 Ruby 中字符串也是一种对象，即 String 对象。无论其结构还是操作和 Symbol 对象都是不同的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Ruby 中每一个对象都有唯一的对象标识符（Object Identifier）,可以通过 object_id 方法来得到一个对象的标识符&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Symbol&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):009:0&amp;gt; :foo.object_id
  =&amp;gt; 1149148
  irb(main):010:0&amp;gt; :foo.object_id
  =&amp;gt; 1149148
  irb(main):011:0&amp;gt; :&quot;foo&quot;.object_id
  =&amp;gt; 1149148

&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;String&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):014:0* &quot;foo&quot;.object_id
  =&amp;gt; 47353958516800
  irb(main):015:0&amp;gt; &quot;foo&quot;.object_id
  =&amp;gt; 47353958510640
  irb(main):016:0&amp;gt; &quot;foo&quot;.object_id
  =&amp;gt; 47353958500960

&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;从上面可以看出，　前三句都是同一个Symble对象，后三个都是不同的String对象&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;可见，每个 String 对象都是不同的，即便他们包含了相同的字符串内容；而对于 Symbol 对象，一个名字（字符串内容）&lt;strong&gt;唯一确定&lt;/strong&gt; 一个 Symbol 对象。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;em&gt;值得注意的是创建 Symbol 对象的字符串中不能含有’\0’字符，而 String 对象是可以的。&lt;/em&gt;
        &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt;  :&quot;fo\0o&quot;
  SyntaxError: compile error
  (irb):1: symbol cannot contain '\0'
       from (irb):1
  irb(main):002:0&amp;gt; :&quot;foo\0&quot;
  SyntaxError: compile error
  (irb):2: symbol cannot contain '\0'
       from (irb):2
  irb(main):003:0&amp;gt; puts &quot;foo\0&quot;.object_id
  24305140
  =&amp;gt; nil
  irb(main):004:0&amp;gt; puts &quot;fo\0o&quot;.object_id
  24301000
  =&amp;gt; nil
  irb(main):005:0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;经过实际测试发现并不是这样(可能是因为ruby版本不一致，测试版本为 2.3.1)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt; irb(main):002:0&amp;gt; :&quot;fo\0o&quot;
 =&amp;gt; :&quot;fo\x00o&quot;
 irb(main):003:0&amp;gt; :&quot;foo\0&quot;
 =&amp;gt; :&quot;foo\x00&quot;
 irb(main):004:0&amp;gt; puts &quot;foo\0&quot;.object_id
 47315761608520
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;除了可以采用一般的字符串，还可以使用操作符（例如+, -, *, /），变量，常量，方法甚至类的名字来创建 Symbol 对象，例如:+就是一个合法的 Symbol 。实际上，在 Ruby 内部操作符、变量等名字本身就是作为 Symbol 处理的，例如当你定义一个实例变量时， Ruby 会自动创建一个 Symbol 对象，例如 @test 对应为 :@test 。
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  # 实例变量的 Symbol

  class Test
   attr_accessor :test
  end
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个类定义了一个具有读写方法的实例变量 @test 。实际上 Ruby 创建了两个 Symbol ，一个是实例变量的 symbol :@test ，另一个是 :test 。那如果使用字符串对象 ”test” 作为参数呢？也可以，仍然会创建两个 symbol ，:test 和 :@test ，为什么还会创建 :test 呢？这是和Ruby的实现相关的（至少Ruby1.8.6里是这样）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意，&lt;strong&gt;类变量 @@test 和实例变量 @test 对应的 Symbol 显然是不同的。记住：名字相同，则Symbol 相同&lt;/strong&gt;。 名字相同， Symbol 相同&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  class Test
    puts :Test.object_id
    Test = 10
    puts :Test.object_id

    def Test
      puts :Test.object_id
    end
  end

  Test.new.Test
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;运行结果&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  224298
  224298
  224298
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;名字不同， Symbol 不同
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  class Test
    puts :Test.object_id

    @@test = 10
    puts :@@test.object_id
    def test
      puts :test.object_id
      @test = 10
      puts :@test.object_id

    end
  end

  t =Test.new
  t.test
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;运行结果&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;224298
288068
79858
288108
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Symbol 表示一个名字，仅此而已&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Symbol 对象一旦定义将一直存在，直到程序执行退出&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;可以通过类方法 Symbol.all_symbols 得到当前 Ruby 程序中定义的所有 Symbol 对象，该方法返回一个 Symbol 对象数组&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;string-和symbol&quot;&gt;String 和　Symbol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;String 类有很多方法，Symbol类只有all_symbols()的类方法和７个实例方法&lt;/li&gt;
  &lt;li&gt;虽然 Symbol 和 String 是不同的对象，但它们之间关系很密切。 Ruby 提供了方法在 Symbol和 String 之间转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;symbol-转化为-string&quot;&gt;Symbol 转化为 String&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Symbol 到 String
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;  irb(main):001:0&amp;gt; :test.id2name
  =&amp;gt; &quot;test&quot;
  irb(main):002:0&amp;gt; :test.to_s
  =&amp;gt; &quot;test&quot;
  irb(main):003:0&amp;gt; :&quot;I am a boy&quot;.to_s
  =&amp;gt; &quot;I am a boy&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意，每个 String 对象都是唯一的，因此对一个 Symbol 调用多次将产生多个 String 对象。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;string-转化为-symbol&quot;&gt;String 转化为 Symbol&lt;/h4&gt;
&lt;p&gt;如果该 Symbol 已经存在，则直接返回。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;String 到 Symbol
    &lt;pre&gt;&lt;code class=&quot;language-irb&quot;&gt;irb(main):001:0&amp;gt; var1 = &quot;test&quot;.to_sym
=&amp;gt; :test
irb(main):002:0&amp;gt; var2 = &quot;test&quot;.intern
=&amp;gt; :test
irb(main):003:0&amp;gt; var1 == var2
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用-symbol&quot;&gt;使用 Symbol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Symbol本质上是 Ruby 符号表中的东西, 使用Symbol可以降低ruby内存消耗，提高执行速度&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通常来讲，当你面临 String 还是 Symbol 的选择时，可以参考以下标准：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;如果使用字符串的内容，这个内容可能会变化，使用 String&lt;/li&gt;
        &lt;li&gt;如果使用固定的名字或者说是标识符，使用 Symbol,比如枚举值、关键字（哈希表关键字、方法的参数）
          &lt;h4 id=&quot;hash中使用&quot;&gt;Hash中使用&lt;/h4&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 Symbol 作为 key
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  hosts = {
      :beijing =&amp;gt; 'machine1',
      :shanghai =&amp;gt; 'machine2',
      :guangzhou =&amp;gt; 'machine3',
      :tianjin' =&amp;gt; 'machine4',
      :shenzhen =&amp;gt; 'machine5'
      }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;使用　String 作为 key
    &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;   hosts = {
      &quot;beijing&quot; =&amp;gt; 'machine1',
      &quot;shanghai&quot; =&amp;gt; 'machine2',
      :guangzhou&quot; =&amp;gt; 'machine3',
      &quot;tianjin&quot; =&amp;gt; 'machine4',
      &quot;shenzhen&quot; =&amp;gt; 'machine5'
      }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每次获取hosts值的时候使用hosts[:beijing],不会创建新的对象。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每次获取hosts值的时候使用hosts[“beijing”],每次都会创建新的String对象，造成多余的内存和性能开销&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;哈希参数&quot;&gt;哈希参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;通常我们定义的函数的参数的个数和顺序是写死的，调用函数的时候要确保参数的个数、顺序匹配，有时候这样很不方便，使用哈希参数可以解决这个问题。&lt;/li&gt;
  &lt;li&gt;ROR 中就大量地运用这种方式，也许你已经看到了，到处都是 Symbol 和哈希&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用哈希参数的方法调用
    &lt;code&gt;ruby
    link_to 'Show', :action =&amp;gt; 'show', :id =&amp;gt; product
    add_column :products, :price, :decimal, :precision =&amp;gt; 8, :scale =&amp;gt; 2, :default =&amp;gt; 0
   &lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>面试准备问题</title>
   <link href="http://canmel.github.io/2017/05/06/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87"/>
   <updated>2017-05-06T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/05/06/面试准备</id>
   <content type="html">&lt;h5 id=&quot;高并发&quot;&gt;高并发&lt;/h5&gt;

&lt;h6 id=&quot;问题&quot;&gt;问题&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是原子操作&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是Executors框架？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。BlockingQueue 接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;高并发优化&quot;&gt;&lt;strong&gt;高并发优化&lt;/strong&gt;&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;从最基础的地方做起，优化我们写的代码，减少必要的资源浪费&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;避免频繁的使用new对象，对于整个应用只需要存在一个实例的类，我们可以使用单例模式。对于String连接操作，使用&lt;code&gt;StringBuffer&lt;/code&gt;或`StringBuilder，对于工具类可以通过静态方法来访问&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;避免使用错误的方式，尽量不用instanceof做条件判断。使用java中效率高的类，比如ArrayList比Vector性能&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;html静态化&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;我们通过一个链接地址访问，通过这个链接地址，服务器对应的模块处理这个请求，转到对应的jsp页面，最后生成我们要的数据。但是，如果上千万个请求的话，有太多的高并发请求，那么就会加重服务器的压力，最坏的情况是把服务器down掉。那么如何避免这种情况的出现呢？如果我们把最初对test.do的请求结果保存成一个html文件，然后每次用户都去访问这个html文件，这样就不用再去访问服务器了，服务器的压力不就减少了？ 当用户去访问，会自动的生成test.html ，然后再显示给用户&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片服务器分离&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对于web服务器来说，图片是最消耗资源的，于是我们有必要把图片与页面进行分离，我们把图片放到独立的图片        服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片的问题而崩                       溃。在图片服务器上，我们可以对不同的配置进行优&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓存
    &lt;ul&gt;
      &lt;li&gt;具体接触过的缓存机制是hibernate的缓存机制。为了避免每次都向数据库中取得数据，我们把用户常常访问到的数据放到内存中，甚至缓存十分大的时候我们可以把内存中的缓存放到硬盘中。还有高级的分布式缓存数据库使用，都可以增加系统的抗压力&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分批传送&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在做某项目的时候，一次传递的参数太多，而且数据库规定一次最多传递的参数最多是三万条，当时有五万条记录，那怎么传送呢？最终是分批传送，电梯里一次乘不下那么多的人，会报超重的bug，那就分批把人送上去,还有一次在考试系统中，如果那么多的考试人员同时提交到数据库中，数据库的压力增大，有时会被down掉，当时采用的方法是使用ajax异步传输，没有等待考生点击提交按钮的时候，就把考生的答案自动提交，这样也避免了突然断电考生前面做过的题出现丢失的现象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库集群&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当面对复杂的应用，用户大量访问的时候，一台数据很快无法满足需求，于是我们需要使用数据库集群或者库表散列。我们在应用程序中安装业务和应用或者功能模块将数据进行分离，不同的模块对应不同的数据库或表，再按照一定的策略对某个页面或者功能进行更小的数据库散列&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DB优化&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在数据库设计的时候就要考虑到后期的维护，数据库三范式是我们设计数据库索要遵循的原则&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;
 &amp;gt; 数据库三范式

 &amp;gt; 第一范式：强调的是列的原子性

 &amp;gt; 第二范式： 首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分

 &amp;gt; 第三范式： 首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;索引的建立：建立索引要适当，如果一个表经常用来被查询，对于增加和修改很少被用到，我们就可以为这个表建立索引，因为对于增加和修改和删除操作时，我们对索引的维护要大大超过索引给我们带来的效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据库建立索引的优缺点&lt;/p&gt;

&lt;p&gt;优点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; * 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

 &amp;gt; * 可以大大加快数据的检索速度，这也是创建索引的最主要的原因

 &amp;gt; * 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义

 &amp;gt; * 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间- 表字段的类型选择要恰当

 &amp;gt; * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; * 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

 &amp;gt; * 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大
 &amp;gt; * 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
 &amp;gt; **适合建立索引的列 **
 &amp;gt; * 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
 &amp;gt; * 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
 &amp;gt; * 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
 &amp;gt; * 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
 &amp;gt; * 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度
 &amp;gt; **不适合建立索引的列 **
 &amp;gt; * 对于那些在查询中很少使用或者参考的列不应该创建索引
 &amp;gt; * 对于那些只有很少数据值的列也不应该增加索引
 &amp;gt; * 对于那些定义为text, image和bit数据类型的列不应该增加索引

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;外键要慎用，因为主键代表这一张表，而外键代表一群表，对表之间进行了关联，在删除修改等需要我们关联&lt;/li&gt;
  &lt;li&gt;在数据库操作上尽量使用prepareStatement，少用Statement，因为&lt;strong&gt;PrepareStatement&lt;/strong&gt;是进行预编译的。connection设置为readOnly，Connection是对书库连接，属于重量级，我们使用即可。连接池的使用，我们可以修改数据库默认的连接数&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;多线程&quot;&gt;多线程&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;进程和线程之间有什么不同&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们如何创建一个线程？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有哪些不同的线程生命周期&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;new&lt;/code&gt;: 新建&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;runnable**&lt;/code&gt;: 调用start()&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;running&lt;/code&gt;: 线程理想状态，cpu分配了时间给了线程&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;blocked&lt;/code&gt;: 阻塞：sleep(), wait() –&amp;gt; 阻塞　–&amp;gt; notify(), notifyAll() –&amp;gt; runnable&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;dead&lt;/code&gt;: 死亡&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何确保main()方法所在的线程是Java程序最后结束的线程&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程之间是如何通信的&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\notify()\notifyAll()方法可以用于线程间通信关于资源的锁的状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么Thread类的sleep()和yield()方法是静态的？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;volatile关键字在Java中有什么作用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是ThreadLocal&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是死锁(Deadlock)？如何分析和避免死锁&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是线程池？如何创建一个Java线程池？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;锁&quot;&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/h5&gt;

&lt;h6 id=&quot;在多线程下一个非常重要的问题就是同步关于同步一般会有以下解决方法&quot;&gt;在多线程下，一个非常重要的问题就是同步,关于同步，一般会有以下解决方法&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在需要同步的方法的方法签名中加入synchronized关键字。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用synchronized块对需要进行同步的代码段进行同步&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;java内置锁&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;设计模式&quot;&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/h5&gt;

&lt;h6 id=&quot;列举几个常用的设计模式&quot;&gt;列举几个常用的设计模式&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;单例模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;单例模式有以下特点：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt; &amp;gt; 单例类只能有一个实例。
 &amp;gt; 单例类必须自己创建自己的唯一实例。
 &amp;gt; 单例类必须给所有其他对象提供这一实例。

&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;单利模式类型&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt; &amp;gt; 懒汉模式：　第一次调用的时候初始化实例（线程不安全，需要加同步）

 &amp;gt; 饿汉模式：　项目加载的时候初始化实例，　自始至终只有一个实例（天生线程安全）

&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工厂模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;工厂模式的两种情况&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;     &amp;gt; 在编码时不能预见需要创建哪种类的实例

     &amp;gt; 系统不应依赖于产品类实例如何被创建、组合和表达的细节
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代理模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;静态代理　&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; &amp;gt; 聚合实现方式中代理类聚合了被代理类，且代理类及被代理类都实现了同一个接口，可实现灵活多变。继承式的实现方式则不够灵活
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;动态代理&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; &amp;gt; 一般来说，对代理模式而言，一个主题类与一个代理类一一对应，这也是静态代理模式的特点。
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，也存在这样的情况，有n各主题类，但是代理类中的“前处理、后处理”都是一样的，仅调用主题不同。也就是说，多个主题类对应一个代理类，共享“前处理，后处理”功能，动态调用所需主题，大大减小了程序规模，这就是动态代理模式的特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JDK动态代理步骤&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &amp;gt; 创建一个实现InvocationHandler接口的类，它必须实现invoke()方法

  &amp;gt; 创建被代理的类及接口

  &amp;gt; 调用Proxy的静态方法，创建一个代理类

  &amp;gt; 通过代理调用方法
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;框架&quot;&gt;框架&lt;/h5&gt;

&lt;h6 id=&quot;mybatis&quot;&gt;Mybatis&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;实现原理&lt;/p&gt;

    &lt;p&gt;MyBatis应用程序根据&lt;code&gt;XML&lt;/code&gt;配置文件创建&lt;code&gt;SqlSessionFactory&lt;/code&gt;，&lt;code&gt;SqlSessionFactory&lt;/code&gt;在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个&lt;code&gt;SqlSession&lt;/code&gt;。&lt;code&gt;SqlSession&lt;/code&gt;包含了执行sql所需要的所有方法，可以通过&lt;code&gt;SqlSession&lt;/code&gt;实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭&lt;code&gt;SqlSession&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;简单易学&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;灵活&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;解除sql与程序代码的耦合&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供映射标签，支持对象与数据库的orm字段关系映射(orm)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供对象关系映射标签，支持对象关系组建维护(orm)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提供xml标签，支持编写动态sql&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;二级缓存机制不佳&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总结&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;专注sql本身，程序员需要自己写sql语句，sql的修改与优化比较方便。它是一个不完全的ORM框架，虽然程序员自己写sql，但它自身也可以实现映射&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;适用与中小型项目&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由&lt;code&gt;apache software foundation&lt;/code&gt; 迁移到了google code，并且改名为MyBatis 。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Object(DAO)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis编程步骤是什么样的&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;创建&lt;strong&gt;SqlSessionFactory&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过SqlSessionFactory创建&lt;strong&gt;SqlSession&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过&lt;strong&gt;sqlsession&lt;/strong&gt;执行数据库操作&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;调用session.commit()提交事务&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;调用session.close()关闭会话&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用MyBatis的mapper接口调用时有哪些要求&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper接口方法名和mapper.xml中定义的每个sql的id相同&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mapper.xml文件中的namespace即是mapper接口的类路径&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简单的说一下MyBatis的一级缓存和二级缓存&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。Mybatis内部存储缓存使用一个&lt;code&gt;HashMap&lt;/code&gt;，key为&lt;code&gt;hashCode+sqlId+Sql&lt;/code&gt;语句。value为从查询出来映射生成的java对象&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的&lt;code&gt;namespace&lt;/code&gt;，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨&lt;code&gt;SqlSession&lt;/code&gt;的。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;springmvc&quot;&gt;SpringMVC&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;工作流程&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;用户发送请求至前端控制器DispatcherServlet&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet收到请求调用HandlerMapping处理器映射器&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;调用&lt;code&gt;HandlerAdapter&lt;/code&gt;处理器适配器&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HandlerAdapter经过适配调用具体的&lt;code&gt;处理器&lt;/code&gt;(Controller，也叫后端控制器)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Controller执行完成返回&lt;code&gt;ModelAndView&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet将ModelAndView传给&lt;code&gt;ViewReslover&lt;/code&gt;视图解析器&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ViewReslover解析后返回具体&lt;code&gt;View&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DispatcherServlet响应用户&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下：&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;文件上传解析，如果请求类型是multipart将通过&lt;code&gt;MultipartResolver&lt;/code&gt;进行文件上传解析；&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;通过&lt;code&gt;HandlerMapping&lt;/code&gt;，将请求映射到&lt;code&gt;处理器&lt;/code&gt;（返回一个&lt;code&gt;HandlerExecutionChain&lt;/code&gt;，它包括一个处理器、多个HandlerInterceptor拦截器）&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;通过&lt;code&gt;HandlerAdapter&lt;/code&gt;支持多种类型的处理器(HandlerExecutionChain中的处理器)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;通过&lt;code&gt;ViewResolver&lt;/code&gt;解析逻辑视图名到具体视图实现；&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;本地化解析&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;渲染具体的视图等&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Rails中Excel的数据导入</title>
   <link href="http://canmel.github.io/2017/04/11/Rails%E4%B8%ADExcel%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5"/>
   <updated>2017-04-11T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/04/11/Rails中Excel的数据导入</id>
   <content type="html">&lt;h4 id=&quot;rails中excel的数据导入&quot;&gt;Rails中Excel的数据导入&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从界面开始
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;首先创建一个表单&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code&gt;&amp;lt;%= bootstrap_form_tag url: '/imports' , :html =&amp;gt; {:id =&amp;gt; 'import_car_form', :multipart =&amp;gt; true} do |f| %&amp;gt;
    &amp;lt;input type=&quot;text&quot; size=&quot;50&quot; id=&quot;upfile&quot; name=&quot;upfile&quot; readonly&amp;gt;
    &amp;lt;%= f.file_field :file, class: &quot;hidden&quot;, hide_label: true, :onchange =&amp;gt; &quot;upfile.value=this.value&quot;, :required =&amp;gt; 'true'%&amp;gt;
    &amp;lt;a href=&quot;javascript:_file.click();&quot; class=&quot;btn btn-sm btn-success&quot;&amp;gt;&amp;lt;span class=&quot;glyphicon glyphicon-plus&quot;&amp;gt;选择文件&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;%= f.submit &quot;上传&quot;, class: &quot;btn btn-sm btn-primary&quot; %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gemfile
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; gem 'roo ~&amp;gt;2.7.1'
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; bundle install
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;routes&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; resouces: imports
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;controller
    &lt;ul&gt;
      &lt;li&gt;controller中建立一个create方法&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在参数中获取临时文件，参数 &lt;code&gt;file&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  # rails默认的路由之一
  # 请求方式post
  def create
      tempfile = params[:file]
      require 'util/excel_util'
      if ExcelUtil.file_present? tempfile
          format = {name: &quot;名称&quot;, age: &quot;年龄&quot;, phone: &quot;手机&quot;}
          results = ExcelUtil.analysis upload_file, format
          # 在这里就获取到了结果集
          # 可以对数据进行持久化操作等
          # 但是得注意多数据操作的事务添加
      end
  end
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ExcelUtil&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  class ExcelUtil
      # 针对单行表头的excel表导入
      # 默认是使用excel的第二行开始计算有效数据，第一行为表头信息
      # upfile: 上传的临时文件
      # format: 定义的表头信息
      #   格式为： {property1: &quot;msg1&quot;, property2: &quot;msg2&quot;}
      # 	eg: format = {name: &quot;名称, price: &quot;价格&quot;, num: &quot;数量&quot;}
      # 返回值： json数组
      #   格式为： [{name: &quot;土豆&quot;， price: &quot;3&quot;, num: &quot;4&quot;}，{name: &quot;里脊肉&quot;， price: &quot;12&quot;, num: &quot;1&quot;}]
      # ==========================================================
      # 调用之前请先确认文件存在与正确性可调用 file_present? == true
      def analysis upfile, format
         require 'roo'
           xlsx = Roo::Spreadsheet.open(file, extension: :xlsx)
           result = []
           xlsx.each_with_pagename do |name, sheet|
            sheet.each do |hash, index|
               result &amp;lt;&amp;lt; hash if index != 0
     		  end
         end
         result
      end
      # 判断文件是否存在或者符合要求
      # 必须是以xlsx或xls结尾的文件
      def file_present? file
        return false if file.nil?
        if file.instance_of? ActionDispatch::Http::UploadedFile
          original_name = file.original_filename
        else
          original_name = file.path
        end
        suffix = original_name.split('.').last
        return suffix === &quot;xls&quot; || suffix === &quot;xlsx&quot; ? true : false
      end
      # TODO 比较复杂的excel的导入（多行表头）
  end
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Mybatis实践</title>
   <link href="http://canmel.github.io/2017/04/11/Mybatis(%E5%88%9D%E8%AF%86)"/>
   <updated>2017-04-11T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/04/11/Mybatis(初识)</id>
   <content type="html">&lt;h3 id=&quot;mybatis实践&quot;&gt;Mybatis实践&lt;/h3&gt;

&lt;h4 id=&quot;mybatis简介&quot;&gt;MyBatis简介&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* Mybatis前身是iBatis,是一个基于java的数据持久层/(半)对相关系映射框架

* Mybatis是对jdbc的封装，是开发人员只需要关注SQL本身，而不需要话费过多的精力去处理如注册驱动，设置参数，创建connection / Statement , 解析结果集等JDBC过程性代码，Bybatis基于XML/注解的方式配置statement，执行SQL，并将执行结果映射成JAVA对象，大大降低了数据库开发难度
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;初识&quot;&gt;初识&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* 使用Mybatis,需要在pom.xml添加依赖,顺手加上mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.1.26&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;* MyBatis的配置分为两类

    * 一类将Mybatis配置进项目中使用，`mybatis-config.xml`,网上关于这类配置很多,一半结合springMVC,会使用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;spring-mybatis.xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
        &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context-3.1.xsd
                                http://www.springframework.org/schema/mvc
                                http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&amp;gt;
        	&amp;lt;!-- 自动扫描 --&amp;gt;
        	&amp;lt;context:component-scan base-package=&quot;com.meedesidy&quot; /&amp;gt;
        	&amp;lt;!-- 引入配置文件 --&amp;gt;
        	&amp;lt;bean id=&quot;propertyConfigurer&quot;
        		class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&amp;gt;
        		&amp;lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&amp;gt;
        	&amp;lt;/bean&amp;gt;
        	&amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        		destroy-method=&quot;close&quot;&amp;gt;
        		&amp;lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&amp;gt;
        		&amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&amp;gt;
        		&amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&amp;gt;
        		&amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&amp;gt;
        		&amp;lt;!-- 初始化连接大小 --&amp;gt;
        		&amp;lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 连接池最大数量 --&amp;gt;
        		&amp;lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 连接池最大空闲 --&amp;gt;
        		&amp;lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 连接池最小空闲 --&amp;gt;
        		&amp;lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 获取连接最大等待时间 --&amp;gt;
        		&amp;lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        	&amp;lt;/bean&amp;gt;
        	&amp;lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&amp;gt;
        	&amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
        		&amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
        		&amp;lt;property name=&quot;plugins&quot;&amp;gt;
        			&amp;lt;list&amp;gt;
        				&amp;lt;bean class=&quot;com.meedesidy.plugin.PagePlugin&quot;&amp;gt;
        					&amp;lt;property name=&quot;pageSqlId&quot; value=&quot;.*pageQuery.*&quot; /&amp;gt;
        					&amp;lt;property name=&quot;dialect&quot; value=&quot;postgres&quot; /&amp;gt;
        				&amp;lt;/bean&amp;gt;
        			&amp;lt;/list&amp;gt;
        		&amp;lt;/property&amp;gt;
        		&amp;lt;!-- 自动扫描mapping.xml文件 --&amp;gt;
        		&amp;lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/meedesidy/mapping/*.xml&quot;&amp;gt;&amp;lt;/property&amp;gt;
      &amp;lt;/bean&amp;gt;
        &amp;lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&amp;gt;
       &amp;lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&amp;gt;
            &amp;lt;property name=&quot;basePackage&quot; value=&quot;com.meedesidy.dao&quot; /&amp;gt;
            &amp;lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
        &amp;lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&amp;gt;
        	&amp;lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        		    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
        	&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    * 另一类配置文件是数据访问接口配置文件，如　`UserMapper.xml`
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;test.mybatis.UserDao&quot;&amp;gt;
    &amp;lt;!-- 这里namespace必须是UserMapper接口的路径” --&amp;gt;
    &amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&amp;gt;
        insert into user(name,age) values(#{name},#{age})
        &amp;lt;!-- 这里sql结尾不能加分号，否则报“ORA-00911”的错误 --&amp;gt;
    &amp;lt;/insert&amp;gt;

    &amp;lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同 --&amp;gt;
    &amp;lt;select id=&quot;getUser&quot; resultType=&quot;User&quot; parameterType=&quot;java.lang.String&quot;&amp;gt;
        select * from user where name=#{name}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;mybatis 需要定义Dao接口，mapper中定义的id与接口中的方法名相同&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mybatis通过JDK的动态代理方式，在启动加载配置文件时，根据配置mapper的xml去生成Dao的实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在mybatis 配置文件中加入扫描，在启动时加载mapper文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;又通过namespace的映射，映射到要实现的接口，代理类通过&lt;code&gt;接口- MapperID&lt;/code&gt;找到相应的MappedStatement&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jdbc配置&quot;&gt;jdbc配置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用配置文件　&lt;code&gt;jdbc.propertis&lt;/code&gt;保存jdbc链接信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JDBC编程的步骤&lt;/strong&gt;：
– 加载数据库驱动
– 创建并获取数据库链接
– 创建jdbc statement对象
– 设置sql语句
– 设置sql语句中的参数(使用preparedStatement)
– 通过statement执行sql并获取结果
– 对sql执行结果进行解析处理
– 释放资源(resultSet、preparedstatement、connection)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MyBatis执行过程&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;– 通过mybatis环境等配置信息构造&lt;strong&gt;SqlSessionFactory&lt;/strong&gt;即会话工厂&lt;/p&gt;

&lt;p&gt;– 由会话工厂创建&lt;strong&gt;sqlSession&lt;/strong&gt;即会话，操作数据库需要通过&lt;strong&gt;sqlSession&lt;/strong&gt;进行。&lt;/p&gt;

&lt;p&gt;– mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行&lt;/p&gt;

&lt;p&gt;– Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对        应一个Mapped Statement对象，sql的id即是Mapped statement的id。&lt;/p&gt;

&lt;p&gt;– Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前               将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。
&lt;img src=&quot;http://olvg7xziu.bkt.clouddn.com/20160725221506672.jpg&quot; alt=&quot;mybatis&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;连接池&quot;&gt;连接池&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;mybatis 把数据源分为三种：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UNPOOLED    不使用连接池的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;POOLED        使用连接池的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JNDI                 使用JNDI实现的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相应地，MyBatis内部分别定义了实现了&lt;strong&gt;Java.sql.DataSource&lt;/strong&gt;接口的&lt;strong&gt;UnpooledDataSource&lt;/strong&gt;，&lt;strong&gt;PooledDataSource&lt;/strong&gt;类来表示&lt;code&gt;UNPOOLED&lt;/code&gt;、&lt;code&gt;POOLED&lt;/code&gt;类型的数据源&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;重复创建javasqlconnection去链接数据库对cpu的开销是不必要的负担连接池解决这个矛盾&quot;&gt;重复创建&lt;code&gt;java.sql.Connection&lt;/code&gt;去链接数据库对cpu的开销是不必要的负担，连接池解决这个矛盾&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;对于需要频繁地跟数据库交互的应用程序，可以在创建了&lt;strong&gt;Connection对象&lt;/strong&gt;，并操作完数据库后，可以不释放掉资源，而是将它放到&lt;strong&gt;内存&lt;/strong&gt;中，当下次需要操作数据库时，可以直接从内存中取出Connection对象，不需要再创建了，这样就极大地节省了创建Connection对象的资源消耗。由于内存也是有限和宝贵的，这又对我们对内存中的Connection对象怎么有效地维护提出了很高的要求。我们将在内存中存放Connection对象的容器称之为 连接池（Connection Pool）&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>使用angularJs （二）</title>
   <link href="http://canmel.github.io/2017/04/11/AngularJs%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%BA%8C"/>
   <updated>2017-04-11T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/04/11/AngularJs的使用（二）</id>
   <content type="html">&lt;h4 id=&quot;使用angularjs-二&quot;&gt;使用angularJs （二）&lt;/h4&gt;
&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;后台支持： Java , springMVC, mybatis, mysql&lt;/li&gt;
  &lt;li&gt;前端框架： Jquery , BootStrap , AngularJs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一般AngularJs 应用在一个单页面的web项目中，一般结构为
    &lt;ul&gt;
      &lt;li&gt;head
        &lt;ul&gt;
          &lt;li&gt;js和css文件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;body
        &lt;ul&gt;
          &lt;li&gt;header&lt;/li&gt;
          &lt;li&gt;sidebar(菜单部分)&lt;/li&gt;
          &lt;li&gt;main-content&lt;/li&gt;
          &lt;li&gt;footer&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一般header和footer都是固定的,点击菜单（sidebar）中的菜单，页面（main-content）部分做出相应的改变，本文仅围绕这个模式书写&lt;/li&gt;
  &lt;li&gt;在&lt;code&gt;main-content&lt;/code&gt;上设置属性&lt;code&gt;ui-view&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;ui-view&lt;/code&gt;是告诉angularJs,今后更改页面，刷新页面，就在这个属性所在的标签下，在你还没有告诉angular要去哪个页面的时候，angular会去路由中找到默认路由去渲染&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;左侧菜单设置设置相应的&lt;code&gt;controller&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;新建&lt;code&gt;sidebarController.js&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;建立go方法
        &lt;ul&gt;
          &lt;li&gt;
            &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;   meedesidy.controller('sidebar', [ '$scope', '$http', '$state', '$stateParams', function($scope, $http, $state, stateParams) {
       //调用go方法跳往指定页面，在ui-view下显示
       $scope.go = function($event, url) {
           $state.go(url);
       }
   }]);

&lt;/code&gt;&lt;/pre&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在菜单中设置ng-click点击事件
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;a ng-click=&quot;go($event, '/users')&quot;&amp;gt;用户菜单&amp;lt;/a&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;这样在页面中点击了&lt;code&gt;用户菜单&lt;/code&gt;在&lt;code&gt;ui-view&lt;/code&gt;中就可以看到路由中定义的templateUrl，即&lt;code&gt;pages/user/index.jsp&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;相应的设置其他路由，即可显示其他界面&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;angularJs中的子路由
    &lt;ul&gt;
      &lt;li&gt;点击每一个菜单会相应的改变&lt;code&gt;ui-view&lt;/code&gt;中的jsp,在jsp中会有属于各页面的路由，如：user.jsp中会有&lt;code&gt;新建用户&lt;/code&gt;的链接，这就需要一个新的子路由，下面开始创建子路由&lt;/li&gt;
      &lt;li&gt;子路由的创建也很简单，之前配置路由的时候会在每个路由下设置一个&lt;code&gt;controller&lt;/code&gt;的属性.&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  .state('user', {
      url: '/user',
      templateUrl: 'pages/user/index.jsp',
      controller: 'user'
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;该属性表明：在当前路由下的页面（现在就是jsp）,使用另外一个controller,这个controller的名字就叫user&lt;/li&gt;
      &lt;li&gt;每一次在&lt;code&gt;xxxController.js&lt;/code&gt;中设置controller的时候，都会设置它的名字，第一个参数就是&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  meedesidy.controller('user', ['$scope', '$http', '$state', '$stateParams', function($scope, $http, $state, $stateParams) {
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;这样在就将页面和新建的controller连在一起了，可以在controller中操作页面中的内容&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;在&lt;code&gt;userController.js&lt;/code&gt;中创建子路由&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  meedesidy.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) {
  //	配置基本路由
      $stateProvider.state('newUser',{
          url: '/user/new',
          templateUrl: 'pages/user/new.jsp',
          controller: 'user'
      }).state('editUser',{
          url: '/user/edit/{id}',
          templateUrl: 'pages/user/new.jsp',
          controller: 'user'
      });
  }]);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;这样在user.jsp中就多了几个子路由：&lt;code&gt;newUser&lt;/code&gt;和&lt;code&gt;editUser&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;子路由的使用
    &lt;ul&gt;
      &lt;li&gt;子路由的使用和基本路由一样，不论是超链接还是使用go方法跳转，都一样使用&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你可以这样使用：&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;a ui-sref=&quot;newUser&quot;&amp;gt;新建用户&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;也可以这样用：&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code&gt;  &amp;lt;a ng-click=&quot;go(newUser)&quot;&amp;gt;新建&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;然后建立相应的go方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;到这里angularjs的基本使用就差不多了剩下的就是一些使用了但关键就是一个数据的双向绑定&quot;&gt;到这里angularJs的基本使用就差不多了，剩下的就是一些使用了，但关键就是一个数据的双向绑定&lt;/h3&gt;

</content>
 </entry>
 
 <entry>
   <title>使用angularJs （一）</title>
   <link href="http://canmel.github.io/2017/04/11/AngularJs%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%B8%80"/>
   <updated>2017-04-11T00:00:00+08:00</updated>
   <id>http://canmel.github.io/2017/04/11/AngularJs的使用（一）</id>
   <content type="html">&lt;h4 id=&quot;使用angularjs-一&quot;&gt;使用angularJs （一）&lt;/h4&gt;

&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;后台支持： Java , springMVC, mybatis, mysql&lt;/li&gt;
  &lt;li&gt;前端框架： Jquery , BootStrap , AngularJs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;创建app.js
    &lt;ul&gt;
      &lt;li&gt;创建ng-app&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;在标签上添加&lt;code&gt;ng-app&lt;/code&gt;属性
        &lt;ul&gt;
          &lt;li&gt;如： &lt;code&gt;&amp;lt;body ng-app='meedesidy'&amp;gt;&amp;lt;/body&amp;gt;&lt;/code&gt;这样就创建了一个名称为&lt;code&gt;meedesidy&lt;/code&gt;的angular项目
            &lt;ul&gt;
              &lt;li&gt;设置路由&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code&gt;app.js&lt;/code&gt;中设置路由，一般都是在spa(single page application 单页面项目)中使用angularJs,这里配置的是在主页面下的子页面的路由&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;代码：&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  meedesidy.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) {

      //	默认路由
      $urlRouterProvider.otherwise('index');

      //	配置基本路由
      $stateProvider.state('index', {
          url: '/index',
          templateUrl: 'pages/index.jsp'
      }).state('user', {
          url: '/user',
          templateUrl: 'pages/user/index.jsp',
          controller: 'user'
      })；
  }]);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;当angular找不到指定的路由会去寻找指定的路由，这里设置的是 index&lt;/li&gt;
      &lt;li&gt;当访问&lt;code&gt;localhost:8080/project/#/user&lt;/code&gt;会去渲染加载&lt;code&gt;user/index.jsp&lt;/code&gt;这个模板,并且会设置当前的控制器名称为&lt;code&gt;menu&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;设置了控制器名称，必须要加载相应的控制器,才能在相应的控制器中控制user/index.jsp中的内容
    * 设置控制器&lt;/li&gt;
      &lt;li&gt;在javascript文件夹下创建controller文件夹，并在controller文件夹下创建&lt;code&gt;userController.js&lt;/code&gt;文件&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在controller文件中添加controller&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // 在app-name 下定义一个 name为 user 的controller
  meedesidy.controller('user', ['$scope', '$http', '$state', '$stateParams', function($scope, $http, $state, $stateParams) {


  }]);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP请求
    &lt;ul&gt;
      &lt;li&gt;http请求需要注入&lt;code&gt;$http&lt;/code&gt;服务&lt;/li&gt;
      &lt;li&gt;请求：&lt;/li&gt;
      &lt;li&gt;
        &lt;pre&gt;&lt;code class=&quot;language-jacascript&quot;&gt;  $http({
      method: &quot;post&quot;,	// 发送一个post请求
      url: &quot;/xxx/user/pageQuery&quot;,
      data: $.param($scope.searchParams),	// 参数，可表达式
      headers : { 'Content-Type': 'application/x-www-form-urlencoded' } //header可选，头部信息
  }).then(function(resp){		//请求成功回调 参数是response
      $scope.datas = resp.data.result;
  }),(function(resp){			//请求失败的回调 参数是response
      console.info(resp);
  });


&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;请求获取到了数据现在就可以在界面上显示了&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>mybatis 缓存</title>
   <link href="http://canmel.github.io/2016/05/21/Mybatis(%E7%BC%93%E5%AD%98)"/>
   <updated>2016-05-21T05:11:27+08:00</updated>
   <id>http://canmel.github.io/2016/05/21/Mybatis(缓存)</id>
   <content type="html">&lt;h4 id=&quot;mybatis-缓存分为一级缓存和二级缓存&quot;&gt;mybatis 缓存分为一级缓存和二级缓存&lt;/h4&gt;

&lt;h5 id=&quot;一级缓存&quot;&gt;一级缓存&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;MyBatis的一级缓存指的是在一个Session域内,session为关闭的时候执行的查询会根据SQL为key被缓存(跟mysql缓存一样,修改任何参数的值都会导致缓存失效)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;– 单独使用MyBatis而不继承Spring,使用原生的MyBatis的SqlSessionFactory来构造sqlSession查询,是可以使用以及缓存的&lt;/p&gt;

&lt;p&gt;— 当参数不变的时候只进行了一次查询,参数变更以后,则需要重新进行查询,而清空缓存以后,参数相同的查询过的SQL也需要重新查询&lt;/p&gt;

&lt;p&gt;– 跟Spring集成的时候(使用mybatis-spring)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

@Repository
public class UserDao extends SqlSessionDaoSupport {
    public User selectUserById(int id) {
        SqlSession session = getSqlSession();
        session.selectOne(&quot;dao.userdao.selectUserByID&quot;, id);
        // 由于session的实现是SqlSessionTemplate的动态代理实现
        // 它已经在代理类内执行了session.close(),所以无需手动关闭session
        return session.selectOne(&quot;dao.userdao.selectUserByID&quot;, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里执行了2次sql查询,看似我们使用了同一个sqlSession,但是实际上因为我们的dao继承了SqlSessionDaoSupport,而SqlSessionDaoSupport内部sqlSession的实现是使用用动态代理实现的,这个动态代理sqlSessionProxy使用一个模板方法封装了select()等操作,每一次select()查询都会自动先执行openSession(),执行完close()以后调用close()方法,相当于生成了一个新的session实例,所以我们无需手动的去关闭这个session()(关于这一点见下面mybatis的官方文档),当然也无法使用mybatis的一级缓存,也就是说mybatis的一级缓存在spring中是没有作用的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;官方文档摘要&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;MyBatis SqlSession provides you with specific methods to handle transactions programmatically. But when using MyBatis-Spring your beans will be injected with a Spring managed SqlSession or a Spring managed mapper. That means that Spring will always handle your transactions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;You cannot call SqlSession.commit(), SqlSession.rollback() or SqlSession.close() over a Spring managed SqlSession. If you try to do so, a UnsupportedOperationException exception will be thrown. Note these methods are not exposed in injected mapper classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;二级缓存&quot;&gt;二级缓存&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;二级缓存就是global caching,它超出session范围之外,可以被所有sqlSession共享,它的实现机制和mysql的缓存一样,开启它只需要在mybatis的配置文件开启settings里的&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;

&amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;以及在相应的Mapper文件(例如userMapper.xml)里开启&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;

&amp;lt;mapper namespace=&quot;dao.userdao&quot;&amp;gt;
   ...  select statement ...
       &amp;lt;!-- Cache 配置 --&amp;gt;
    &amp;lt;cache
        eviction=&quot;FIFO&quot;
        flushInterval=&quot;60000&quot;
        size=&quot;512&quot;
        readOnly=&quot;true&quot; /&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;需要注意的是global caching的作用域是针对Mapper的Namespace而言的,也就是说只在有在这个Namespace内的查询才能共享这个cache.例如上面的 dao.userdao namespace, 下面是官方文档的介绍&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;It’s important to remember that a cache configuration and the cache instance are bound to the namespace of the SQL Map file. Thus, all statements in the same namespace as the cache are bound by it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;当我们访问两次 /getUser 这个url,查看日志输出&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;DEBUG - Creating a new SqlSession
DEBUG - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@659812] was not registered for synchronization because synchronization is not active
DEBUG - Cache Hit Ratio [dao.userdao]: 0.0
DEBUG - Fetching JDBC Connection from DataSource
DEBUG - JDBC Connection [jdbc:mysql://127.0.0.1:3306/mybatistest?characterEncoding=utf8, UserName=root@localhost, MySQL-AB JDBC Driver] will not be managed by Spring
DEBUG - ooo Using Connection [jdbc:mysql://127.0.0.1:3306/mybatistest?characterEncoding=utf8, UserName=root@localhost, MySQL-AB JDBC Driver]
DEBUG - ==&amp;gt; Preparing: SELECT * FROM user WHERE id = ?
DEBUG - ==&amp;gt; Parameters: 1(Integer)
DEBUG - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@659812]
DEBUG - Returning JDBC Connection to DataSource
DEBUG - Invoking afterPropertiesSet() on bean with name 'index'
DEBUG - Rendering view [org.springframework.web.servlet.view.JstlView: name 'index'; URL [/index.jsp]] in DispatcherServlet with name 'dispatcher'
DEBUG - Added model object 'org.springframework.validation.BindingResult.user' of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name 'index'
DEBUG - Added model object 'user' of type [bean.User] to request in view with name 'index'
DEBUG - Forwarding to resource [/index.jsp] in InternalResourceView 'index'
DEBUG - Successfully completed request
DEBUG - Returning cached instance of singleton bean 'sqlSessionFactory'
DEBUG - DispatcherServlet with name 'dispatcher' processing GET request for [/user/getUser]
DEBUG - Looking up handler method for path /user/getUser
DEBUG - Returning handler method [public java.lang.String controller.UserController.getUser(org.springframework.ui.Model)]
DEBUG - Returning cached instance of singleton bean 'userController'
DEBUG - Last-Modified value for [/user/getUser] is: -1
DEBUG - Creating a new SqlSession
DEBUG - SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@539a92] was not registered for synchronization because synchronization is not active
DEBUG - Cache Hit Ratio [dao.userdao]: 0.5
DEBUG - Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@539a92]
DEBUG - Rendering view [org.springframework.web.servlet.view.JstlView: name 'index'; URL [/index.jsp]] in DispatcherServlet with name 'dispatcher'
DEBUG - Added model object 'org.springframework.validation.BindingResult.user' of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name 'index'
DEBUG - Added model object 'user' of type [bean.User] to request in view with name 'index'
DEBUG - Forwarding to resource [/index.jsp] in InternalResourceView 'index'
DEBUG - Successfully completed request
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;可以看出第二次访问同一个url的时候相同的查询 hit cache了,这就是global cache的作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文来自&lt;a href=&quot;http://www.cnblogs.com/zemliu/archive/2013/08/05/3239014.html&quot;&gt;今天的风儿好喧嚣啊~ MyBatis 缓存&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>高并发控制</title>
   <link href="http://canmel.github.io/2016/05/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%8E%A7%E5%88%B6"/>
   <updated>2016-05-21T05:11:27+08:00</updated>
   <id>http://canmel.github.io/2016/05/21/高并发的控制</id>
   <content type="html">&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优化代码&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;避免使用&lt;code&gt;new&lt;/code&gt;对象，对整个应用尽量使用一个对象，可使用单利模式。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对&lt;code&gt;String&lt;/code&gt;链接操作，使用&lt;code&gt;StringBuffer&lt;/code&gt;或&lt;code&gt;StringBuildder&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;html静态化&quot;&gt;html静态化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;高并发下服务器转化&lt;code&gt;jsp&lt;/code&gt;为&lt;code&gt;html&lt;/code&gt;会加重服务器负担,有可能的话，使用静态&lt;code&gt;html&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;图片服务器分离&quot;&gt;图片服务器分离&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;图片等静态资源放在独立服务器上，让服务器专注数据的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;缓存&quot;&gt;缓存&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code&gt;hibernate&lt;/code&gt;的缓存机制，或使用缓存，如&lt;code&gt;redis&lt;/code&gt;，以缓解服务器压力&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分批传送&quot;&gt;分批传送&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;有时还传送数据过大，需将数据分批传送，防止一次大量数据传输，数据保存时失败，导致大量数据丢失&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据库集群&quot;&gt;数据库集群&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;面对大量的数据请求，一台服务器可能已经无法满足数据的交换，于是就需要数据库集群或数据表散列。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;db优化&quot;&gt;DB优化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;遵循数据库设计三范式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;适当建立索引&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;慎用外键&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>rubymine激活</title>
   <link href="http://canmel.github.io/2016/05/21/rubymine%E6%BF%80%E6%B4%BB"/>
   <updated>2016-05-21T05:11:27+08:00</updated>
   <id>http://canmel.github.io/2016/05/21/rubymine激活</id>
   <content type="html">&lt;pre&gt;&lt;code&gt;4UXNY6NKFS-eyJsaWNlbnNlSWQiOiI0VVhOWTZOS0ZTIiwibGljZW5zZWVOYW1lIjoiVXNlciBDb2RlciIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJGb3IgZWR1Y2F0aW9uYWwgdXNlIG9ubHkiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifSx7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxOC0wMi0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTAyLTE0In0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMTgtMDItMTQifV0sImhhc2giOiI1Mjk5NjU1LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-vaN2LDXEHZhJuA6ty/l8gqzoAfnxXdgWVDw8boMp8HzNP9J573xXWOy9THOjEgl0350zGrLyU5Yfb3FLCBbKCIQaVyKES1Y32ykO7oAPg74zikYTCfP582HB0pzgvr7jsFFxgyCYvwU+UavEcCyOV0/iF3WJIuP5l013w6xcpcCVS9TvarpFFExKilKzyg1295t8Cki1Y6uJkW3ZcexPfED/iEkhdb5CMfYeuTZ2DvC/+b0Ec7N0gitBxIQsJwRZvVGXcd2GVG+Tersgygk0rZwGoVmdXh5k58Y3ZWkkKGfeBomZwrdx0ONo6GWtrL2sEIl0LKpjA5EKrxxHxsN6kA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==

&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Jekyll Introduction</title>
   <link href="http://canmel.github.io/lessons/2011/12/29/jekyll-introduction"/>
   <updated>2011-12-29T00:00:00+08:00</updated>
   <id>http://canmel.github.io/lessons/2011/12/29/jekyll-introduction</id>
   <content type="html">
&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we’ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&quot;what-is-jekyll&quot;&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as “a simple, blog aware, static site generator”.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;what-does-jekyll-do&quot;&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, 
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id=&quot;jekyll-is-not-blogging-software&quot;&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id=&quot;why-should-i-care&quot;&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
  &lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
  &lt;li&gt;No internet connection required.&lt;/li&gt;
  &lt;li&gt;Ability to publish via git.&lt;/li&gt;
  &lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
  &lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
  &lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-jekyll-works&quot;&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately 
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id=&quot;initial-setup&quot;&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you’ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id=&quot;the-jekyll-application-base-format&quot;&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;
  Stores configuration data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;
  This folder is for partial views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;
  This folder is for the main templates your content will be inserted into.
  You can have different layouts for different pages or page sections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;
  This folder contains your dynamic content/posts.
  the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;
  This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;
  This folder is not part of the standard jekyll structure.
  The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
  Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;jekyll-configuration&quot;&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;content-in-jekyll&quot;&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content “objects” get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id=&quot;posts-and-pages&quot;&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id=&quot;working-with-posts&quot;&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. 
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post’s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy “set”.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy “lessons/beginner”. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won’t find “lessons” and “beginner” as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id=&quot;working-with-pages&quot;&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;templates-in-jekyll&quot;&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page’s or post’s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
Templates should be coded in HTML and contain YAML Front Matter. 
All templates can contain Liquid code to work with your site’s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sub-templates&quot;&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they 
define another “root” layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id=&quot;includes&quot;&gt;Includes&lt;/h3&gt;
&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id=&quot;using-liquid-for-templating&quot;&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id=&quot;what-is-liquid&quot;&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files 
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data.&lt;/p&gt;

&lt;h3 id=&quot;why-do-we-have-to-use-liquid&quot;&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;. 
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id=&quot;liquid-is-not-programmer-friendly&quot;&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can’t do jackshit in liquid that hasn’t been allowed explicitly by the implementation.
What’s more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll’s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. 
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to 
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;
My personal stance is to not invest time trying to hack liquid. It’s really unnecessary
&lt;em&gt;from a programmer’s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I’ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-assets&quot;&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-parses-files&quot;&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;
  This is done with textile or markdown.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;  &lt;br /&gt;
  These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
  Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through 
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id=&quot;formatting-files-for-parsing&quot;&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We’ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;defining-layouts-for-posts-and-templates-parsing&quot;&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you’d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-generates-the-final-static-files&quot;&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll’s job is to generate a static representation of your website. 
The following is an outline of how that’s done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one 
  big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
  At this stage your site is one big computed ruby object.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;
  Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
  Once the post is parsed and liquified inside the the proper layout structure, the layout itself is “liquified”. &lt;br /&gt;
 &lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
  hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;
 Finally the liquid templates are “rendered”, thereby processing any liquid syntax provided in the templates
 and saving the final, static representation of the file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to 
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you’ll iterate through and format 
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
  &lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you’d like.&lt;/p&gt;
</content>
 </entry>
 

</feed>
